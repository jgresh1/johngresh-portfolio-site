<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>John Gresh : Portfolio Web Game</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
body { margin: 0; overflow: hidden; background-color: #000; cursor: grab; -webkit-overflow-scrolling: touch; overscroll-behavior: none; }
canvas { display: block; touch-action: none; }
#instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255, 255, 255, 0.9); font-family: 'VT323', monospace; font-size: 18px; text-shadow: 2px 2px 4px black; pointer-events: none; text-align: center; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 0; z-index: 10; }
#coin-counter { position: absolute; top: 20px; right: 20px; color: #ffd700; font-family: 'VT323', monospace; font-size: 36px; text-shadow: 3px 3px 0px black; padding: 10px 20px; background: rgba(26, 5, 58, 0.8); border: 4px solid black; z-index: 15; display: block; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); pointer-events: none; }
.scene-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 5, 58, 0.9); z-index: 1000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(3px); }
.overlay-container { width: 85%; max-width: 1100px; height: 85vh; overflow-y: auto; padding: 30px; border: 4px solid #000; box-shadow: 0 0 50px rgba(255, 125, 92, 0.9); background-color: #1a1a2e; color: #ffffff; font-family: 'VT323', monospace; line-height: 1.3; }
#tshirtsContainer { max-width: 650px; height: auto; max-height: 85vh; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }

/* Modified #askJohnContainer for the chat interface */
#askJohnContainer {
    max-width: 800px;
    /* height: 85vh; <- Inherited from .overlay-container */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    text-align: left;
    box-shadow: 0 0 50px rgba(255, 167, 0, 0.9);
    /* padding-bottom: 20px; <- Inherited from .overlay-container padding */
    overflow-y: hidden; /* Prevent double scrollbars, let chat window handle it */
}

#tshirtsContainer { box-shadow: 0 0 50px rgba(0, 119, 182, 0.9); }
/* #askJohnContainer { box-shadow: 0 0 50px rgba(255, 167, 0, 0.9); } <- Moved to specific selector above */
#miniGamesContainer { box-shadow: 0 0 50px rgba(106, 13, 173, 0.9); display: flex; flex-direction: column; justify-content: flex-start; align-items: center; text-align: center; }
.close-btn { position: fixed; top: 20px; right: 20px; padding: 10px 20px; font-size: 24px; font-family: 'VT323', monospace; background-color: #e63946; color: white; border: 3px solid black; cursor: pointer; border-radius: 0; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s; z-index: 1001; }
.close-btn:hover { background-color: #ff5a5f; }
.close-btn:active { transform: translate(3px, 3px); box-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
.overlay-container::-webkit-scrollbar { width: 14px; }
.overlay-container::-webkit-scrollbar-track { background: #2a1a3d; border-left: 2px solid black; }
.overlay-container::-webkit-scrollbar-thumb { background: #6c6383; border: 2px solid black; border-radius: 0; }
.overlay-container::-webkit-scrollbar-thumb:hover { background: #8a505d; }
.resume-header { text-align: center; margin-bottom: 30px; border-bottom: 4px dashed #6c6383; padding-bottom: 20px; width: 100%; }
.resume-header h1 { font-size: 48px; margin: 0; color: #ff7d5c; text-shadow: 3px 3px 0px rgba(0,0,0,0.5); }
#tshirtsContainer .resume-header h1 { color: #0077b6; }
#askJohnContainer .resume-header h1 { color: #ffa700; }
#miniGamesContainer .resume-header h1 { color: #9d4edd; }
.resume-header p { font-size: 22px; margin: 5px 0 0 0; color: #d4a3a3; }
.resume-section { margin-bottom: 30px; }
.resume-section h2 { font-size: 30px; color: #2a9d8f; border-bottom: 2px solid #2a9d8f; padding-bottom: 5px; margin-bottom: 15px; text-transform: uppercase; }
.job, .education-item { margin-bottom: 20px; padding-left: 10px; }
.job-title, .degree-title { font-size: 26px; color: #e63946; }
.company, .school { font-size: 22px; color: #ffffff; }
.dates { font-size: 20px; color: #a37c7c; display: block; margin-bottom: 8px; }
.responsibilities, .skills-list { font-size: 21px; list-style: none; padding: 0; margin: 0; color: #fdf6e3; }

/* Ensure list items are positioned correctly for the bullet points */
.responsibilities li, .skills-list li { position: relative; padding-left: 20px; margin-bottom: 5px; }

.responsibilities li:before, .skills-list li:before { content: '>'; position: absolute; left: 0; color: #0077b6; }
.resume-layout { display: flex; flex-wrap: wrap; gap: 30px; }
.layout-main { flex: 2; min-width: 300px; }
.layout-sidebar { flex: 1; min-width: 250px; }
.progress-container { width: 90%; background-color: #2a1a3d; border: 4px solid #000; margin: 25px 0; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); }
.progress-bar { background-color: #0077b6; height: 35px; width: 60%; background-image: linear-gradient(90deg, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.25) 5%, transparent 5%, transparent 100%); background-size: 20px 100%; }
#askJohnContainer .progress-bar { background-color: #ffa700; width: 50%; }
#miniGamesContainer .progress-bar { background-color: #6a0dad; width: 30%; }
.loading-text { font-size: 28px; color: #ffffff; margin-top: 15px; }

/* --- CHAT INTERFACE STYLES --- */
#chat-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex-grow: 1;
    overflow: hidden;
}

#chat-window {
    flex-grow: 1;
    background-color: #2a1a3d;
    border: 4px solid #000;
    padding: 15px;
    overflow-y: auto;
    margin-bottom: 15px;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
}

/* Custom scrollbar for the chat window specifically */
#chat-window::-webkit-scrollbar { width: 14px; }
#chat-window::-webkit-scrollbar-track { background: #1a1a2e; border-left: 2px solid black; }
#chat-window::-webkit-scrollbar-thumb { background: #ffa700; border: 2px solid black; border-radius: 0; }
#chat-window::-webkit-scrollbar-thumb:hover { background: #ffc107; }

#chat-messages {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message {
    padding: 10px 15px;
    border: 3px solid #000;
    max-width: 80%;
    word-wrap: break-word;
    font-size: 20px;
    line-height: 1.4;
}

.user-message {
    align-self: flex-end;
    background-color: #0077b6;
    color: white;
    box-shadow: 5px 5px 0px rgba(0,0,0,0.8);
}

.bot-message {
    align-self: flex-start;
    background-color: #e63946;
    color: white;
    box-shadow: -5px 5px 0px rgba(0,0,0,0.8);
}

#chat-input-area {
    display: flex;
    gap: 10px;
}

#chat-input {
    flex-grow: 1;
    padding: 10px 15px;
    font-family: 'VT323', monospace;
    font-size: 22px;
    background-color: #1a1a2e;
    color: #ffffff;
    border: 4px solid #000;
    box-shadow: 5px 5px 0px rgba(0,0,0,0.8);
}

#chat-input:focus {
    outline: none;
    border-color: #ffa700;
}

#send-btn {
    padding: 10px 20px;
    font-family: 'VT323', monospace;
    font-size: 22px;
    background-color: #ffa700;
    color: black;
    border: 4px solid #000;
    cursor: pointer;
    box-shadow: 5px 5px 0px rgba(0,0,0,0.8);
    transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s;
}

#send-btn:hover {
    background-color: #ffc107;
}

#send-btn:active {
    transform: translate(3px, 3px);
    box-shadow: 2px 2px 0px rgba(0,0,0,0.8);
}

#send-btn:disabled {
    background-color: #6c6383;
    cursor: not-allowed;
    transform: none;
    box-shadow: 5px 5px 0px rgba(0,0,0,0.8);
}
/* --- END CHAT INTERFACE STYLES --- */

#mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 200px; z-index: 20; display: none; justify-content: space-between; align-items: center; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
#joystick-zone { position: relative; width: 150px; height: 150px; pointer-events: auto; margin-left: 20px; touch-action: none; }
#action-buttons { display: flex; gap: 20px; pointer-events: auto; margin-right: 40px; touch-action: none; }
.action-btn { width: 90px; height: 90px; border-radius: 50%; background: rgba(255, 69, 0, 0.5); border: 3px solid rgba(255, 255, 255, 0.7); color: white; font-family: 'VT323', monospace; font-size: 24px; display: flex; justify-content: center; align-items: center; user-select: none; transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s; }
.action-btn:active, .action-btn.active { background: rgba(255, 69, 0, 0.8); transform: scale(0.95); }
#pong-canvas { background-color: #000; border: 4px solid #9d4edd; display: block; margin: 0 auto 20px auto; cursor: ns-resize; touch-action: none; }
#pong-score { font-size: 36px; color: #fff; text-align: center; margin-bottom: 15px; }
#pong-instructions { text-align: center; font-size: 20px; margin-top: 5px; color: #d4a3a3; padding-bottom: 20px; }
#pong-round-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 36px; color: #ff7d5c; background-color: rgba(26, 5, 58, 0.95); padding: 20px 40px; border: 3px solid #ff7d5c; display: none; z-index: 1002; text-align: center; white-space: nowrap; box-shadow: 0 0 30px rgba(255, 125, 92, 0.7); }
@media (max-width: 800px) {
#instructions { display: none; }
#coin-counter { font-size: 20px; top: 10px; right: 10px; padding: 4px 8px; }
.close-btn { top: 10px; right: 10px; padding: 8px 16px; font-size: 20px; border: 3px solid black; box-shadow: 3px 3px 0px rgba(0,0,0,0.8); }
.close-btn:active { transform: translate(1px, 1px); box-shadow: 1px 1px 0px rgba(0,0,0,0.8); }
.overlay-container { margin-top: 60px; height: calc(100vh - 80px); max-height: none; width: 95%; padding: 15px; }
.resume-header h1 { font-size: 36px; }
#pong-score { font-size: 28px; }
#pong-round-message { font-size: 24px; padding: 15px 25px; white-space: normal; }
/* Mobile adjustments for chat input */
#chat-input, #send-btn { font-size: 18px; padding: 8px 12px; }
}
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {
.close-btn { position: fixed !important; z-index: 1001 !important; top: 15px !important; right: 15px !important; padding: 12px 24px !important; font-size: 26px !important; background-color: #e63946 !important; border: 4px solid black !important; }
.overlay-container { margin-top: 80px !important; height: calc(100vh - 100px) !important; max-height: none !important; }
}
</style>
</head>
<body>
<div id="instructions">WASD/Arrows: Move | Space: Jump | Drag: Look<br>Click the store signs. Find the hidden coins!</div>
<div id="coin-counter">COINS: 0 / 6</div>
<div id="resumeOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="resumeContainer" class="overlay-container">
<div class="resume-header"><h1>John Gresh</h1><p>(336) 995-4119 | johngresh.usa@gmail.com</p></div>
<div class="resume-layout">
<div class="layout-main">
<section class="resume-section">
<h2>Experience</h2>
<div class="job"><div class="job-title">Maintenance Technician</div><div class="company">Toyota Battery Factory</div><span class="dates">July 2024 - November 2024</span>
<ul class="responsibilities"><li>General Maintenance</li><li>Preventative Maintenance</li><li>Work orders/Cost Center Management</li><li>Performing Job Safety Analysis</li></ul>
</div>
<div class="job"><div class="job-title">Assistant Manager</div><div class="company">New Balance</div><span class="dates">October 2021 - Current</span>
<ul class="responsibilities"><li>Assisting in the general operation of the store</li><li>Opening and closing the store</li><li>Overseeing the customer experience</li><li>Fitting customers for shoes</li></ul>
</div>
<div class="job"><div class="job-title">Sales Representative</div><div class="company">GNC</div><span class="dates">March 2019 - July 2019, Charlotte NC</span>
<ul class="responsibilities"><li>Opening/Closing store</li><li>Inventory checks</li><li>Customer relations</li><li>Register</li><li>Cleaning</li></ul>
</div>
<div class="job"><div class="job-title">Lifeguard</div><div class="company">Forsyth Country Club</div><span class="dates">2016 - 2017 Summer</span>
<ul class="responsibilities"><li>Lifeguarding</li><li>Checking in guests</li><li>Cleaning pool deck and pool services</li><li>Testing pool chemicals/Adding chemicals</li><li>Strong emphasis on customer relations</li></ul>
</div>
<div class="job"><div class="job-title">Bussing tables / working in kitchen</div><div class="company">Vincenzo's Restaurant</div><span class="dates">January 2015 - December 2015, Winston-salem NC</span>
<ul class="responsibilities"><li>Making bread/Cleaning dishes/Making salads/ Bus Boy</li><li>Cleaning station</li><li>Customer relations</li></ul>
</div>
</section>
</div>
<div class="layout-sidebar">
<section class="resume-section">
<h2>Education</h2>
<div class="education-item"><div class="degree-title">Mechatronics Technician</div><div class="school">Forsyth Tech</div><span class="dates">August 2022 - May 2024, Winston Salem NC</span></div>
<div class="education-item"><div class="degree-title">Internship</div><div class="school">ThinkPLC</div><span class="dates">August 2022 - May 2023, Winston Salem NC</span></div>
<div class="education-item"><div class="degree-title">High School Diploma</div><div class="school">Mount Tabor</div><span class="dates">August 2013 - May 2017, Winston Salem NC</span></div>
</section>
<section class="resume-section">
<h2>Skills</h2>
<ul class="skills-list">
<li>OSHA 10-Hr Certified</li><li>Electrical Safe Work Practices Certified</li><li>Control of Hazardous Energy Certified</li><li>PLC installation / proficient</li><li>PLC programming (RSLogix) / proficient</li><li>Python / proficient</li><li>C++ / beginner</li><li>Matlab / beginner</li><li>Sales experience (GNC, New Balance)</li><li>Cell phone and electronic repair (iPhone/Mac)</li>
</ul>
</section>
</div>
</div>
</div>
</div>
<div id="projectsOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="projectsContainer" class="overlay-container">
<div class="resume-header"><h1>Projects</h1></div>
<section class="resume-section"><h2>Featured Work</h2><ul class="skills-list"><li>This Website</li></ul></section>
</div>
</div>
<div id="tshirtsOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="tshirtsContainer" class="overlay-container">
<div class="resume-header"><h1>T-Shirt Store (WIP)</h1></div>
<p class="loading-text">Initializing Storefront...</p>
<div class="progress-container"><div class="progress-bar"></div></div>
<p class="loading-text">> later this week</p>
</div>
</div>

<div id="askJohnOverlay" class="scene-overlay">
    <button class="close-btn">[X] BACK</button>
    <div id="askJohnContainer" class="overlay-container">
        <div class="resume-header">
            <h1>Ask John (AI)</h1>
            <p>Chat with an AI trained on John's professional background.</p>
        </div>

        <div id="chat-container">
            <div id="chat-window">
                <div id="chat-messages">
                    </div>
            </div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type your question...">
                <button id="send-btn">SEND</button>
            </div>
        </div>
    </div>
</div>
<div id="miniGamesOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="miniGamesContainer" class="overlay-container">
<div class="resume-header"><h1>Pong AI</h1></div>
<div id="pong-score">Player: <span id="player-score">0</span> | AI: <span id="ai-score">0</span> | Round: <span id="pong-round">1</span></div>
<canvas id="pong-canvas"></canvas>
<div id="pong-instructions">
<p>First to 5 wins the round. The AI adapts each round!</p>
<p>Desktop: Use Mouse or W/S/Up/Down Arrows.</p>
<p>Mobile: Drag your paddle.</p>
</div>
</div>
</div>
<div id="pong-round-message"></div>
<div id="mobile-controls"><div id="joystick-zone"></div><div id="action-buttons"><div id="jump-btn" class="action-btn">JUMP</div></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
<script id="pixel-vertex-shader" type="x-shader/x-vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</script>
<script id="pixel-fragment-shader" type="x-shader/x-fragment">uniform sampler2D tDiffuse; uniform vec2 resolution; uniform float pixelSize; varying vec2 vUv; void main() { vec2 dxy = pixelSize / resolution; vec2 coord = dxy * floor(vUv / dxy + 0.5); gl_FragColor = texture2D(tDiffuse, coord); }</script>
<script id="sky-vertex-shader" type="x-shader/x-vertex">varying vec3 vWorldPosition; void main() { vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</script>
<script id="sky-fragment-shader" type="x-shader/x-fragment">
uniform vec3 colorZenith; uniform vec3 colorHorizonBright; uniform vec3 colorHorizonDark; uniform vec3 sunDirection; varying vec3 vWorldPosition;
void main() {
vec3 direction = normalize(vWorldPosition); float h = max(0.0, direction.y);
float verticalFade = pow(1.0 - h, 2.5);
float sunAlignment = dot(direction, sunDirection); float horizontalFactor = (sunAlignment + 1.0) * 0.5;
horizontalFactor = smoothstep(0.3, 0.7, horizontalFactor);
vec3 baseHorizonColor = mix(colorHorizonDark, colorHorizonBright, horizontalFactor);
vec3 skyColor = mix(colorZenith, baseHorizonColor, verticalFade);
float sunHotspot = max(0.0, sunAlignment); sunHotspot = pow(sunHotspot, 32.0);
vec3 hotspotColor = vec3(1.0, 0.9, 0.7); skyColor += hotspotColor * sunHotspot * 0.8;
gl_FragColor = vec4(skyColor, 1.0);
}
</script>
<script>
let scene, camera, renderer, composer, pixelPass;
let cameraRig, cameraPitch;
let raycaster, mouse;
const clickableObjects = [];
const clock = new THREE.Clock();
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, s: false, d: false, ' ': false };
let joystickInput = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let lookTouchId = null;
let isSceneActive = true;
const coins = [];
let coinsCollected = 0;
const TOTAL_COINS = 6;
let coinGeometry, coinMaterials;
const fireworks = [];
let fireworkTimer = null;
const playerHeight = 10;
let isJumping = false;
let yVelocity = 0;
const gravity = -80;
const jumpForce = 30;
const ROAD_CONFIG = { width: 36, length: 1500, startZ: 260, shoulderWidth: 10 };
ROAD_CONFIG.endZ = ROAD_CONFIG.startZ + ROAD_CONFIG.length;
const TUNNEL_CONFIG = { startZ: 350, length: 500, width: 50, height: 35, wallThickness: 10, clearanceWidth: 180 };
TUNNEL_CONFIG.endZ = TUNNEL_CONFIG.startZ + TUNNEL_CONFIG.length;
const colors = {
skyZenith: 0x1a053a, skyHorizonDark: 0x2a1a3d, horizonGlow: 0xff7d5c, asphalt: 0x1a1a2e, asphaltLine: 0x6c6383,
brick: 0x8a505d, grass: 0x182c25, stucco: 0xd4a3a3, stuccoDark: 0xa37c7c, windowGlowBright: 0xfff5c3,
windowGlowDim: 0x839db5, signResume: 0xe63946, signTshirts: 0x0077b6, signProjects: 0x2a9d8f, signAskJohn: 0xffa700,
signMiniGames: 0x6a0dad,
billboardGlow: 0xffe8a3, billboardText: 0xd95763, treeDark: 0x1b3028, treeTrunk: 0x4a3f35, metalDark: 0x1a1a2e,
poleMetal: 0x4a4f63, poleGlow: 0xffe0a3, coinGold: 0xffd700, coinDarkGold: 0xc6a100, tunnelConcrete: 0x3a3a4a,
tunnelFacade: 0x5a5a6a, tunnelLight: 0xffa050
};
const sunDirectionVector = new THREE.Vector3(-1, 0.25, -0.8).normalize();

function isMobileDevice() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800; }
function isIPad() { return /iPad/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

class PongGame {
constructor(canvasId) {
this.canvas = document.getElementById(canvasId);
this.ctx = this.canvas.getContext('2d');
this.isRunning = false; this.animationFrameId = null; this.isServing = false; this.serveTimeoutId = null;
this.width = 640; this.height = 400;
this.canvas.width = this.width; this.canvas.height = this.height;
this.paddleWidth = 10; this.paddleHeight = 80; this.playerSpeed = 8; this.ballSize = 10;
this.baseBallSpeed = isMobileDevice() ? 6 : 5;
this.round = 1; this.aiBaseSpeed = 4; this.aiReactionFrequency = 0.1; this.aiErrorMargin = 35;
this.player = { x: this.paddleWidth, y: this.height / 2 - this.paddleHeight / 2, w: this.paddleWidth, h: this.paddleHeight, score: 0 };
this.ai = { x: this.width - this.paddleWidth * 2, y: this.height / 2 - this.paddleHeight / 2, w: this.paddleWidth, h: this.paddleHeight, score: 0, targetY: this.height / 2 };
this.ball = { x: this.width / 2, y: this.height / 2, w: this.ballSize, h: this.ballSize, dx: 0, dy: 0, speed: this.baseBallSpeed };
this.pongKeys = { ArrowUp: false, ArrowDown: false, W: false, S: false };
this.isDraggingPaddle = false;
this.setupEventListeners();
this.resetGame();
}
adjustDifficulty() {
this.aiBaseSpeed = 4 + this.round * 0.5;
this.aiReactionFrequency = Math.min(0.9, 0.1 + this.round * 0.08);
this.aiErrorMargin = Math.max(5, 35 - this.round * 4);
this.ball.speed = this.baseBallSpeed + this.round * 0.3;
}
setupEventListeners() {
document.addEventListener('keydown', (e) => {
    // MODIFICATION: Prevent pong keys from firing if the chat input is focused
    if (document.activeElement.id === 'chat-input') return;

    if (this.isRunning) {
        if (e.key === 'ArrowUp') { this.pongKeys.ArrowUp = true; e.preventDefault(); }
        if (e.key === 'ArrowDown') { this.pongKeys.ArrowDown = true; e.preventDefault(); }
        if (e.key === 'w' || e.key === 'W') { this.pongKeys.W = true; e.preventDefault(); }
        if (e.key === 's' || e.key === 'S') { this.pongKeys.S = true; e.preventDefault(); }
    }
});
document.addEventListener('keyup', (e) => {
if (e.key === 'ArrowUp') this.pongKeys.ArrowUp = false;
if (e.key === 'ArrowDown') this.pongKeys.ArrowDown = false;
if (e.key === 'w' || e.key === 'W') this.pongKeys.W = false;
if (e.key === 's' || e.key === 'S') this.pongKeys.S = false;
});
this.canvas.addEventListener('mousemove', (e) => {
if (this.isRunning && !isMobileDevice()) { this.handlePointerMove(e.clientY); }
});
this.canvas.addEventListener('touchstart', (e) => {
if (this.isRunning) { e.preventDefault(); this.isDraggingPaddle = true; this.handlePointerMove(e.touches[0].clientY); }
}, { passive: false });
this.canvas.addEventListener('touchmove', (e) => {
if (this.isRunning && this.isDraggingPaddle) { e.preventDefault(); this.handlePointerMove(e.touches[0].clientY); }
}, { passive: false });
this.canvas.addEventListener('touchend', (e) => { this.isDraggingPaddle = false; });
}
handlePointerMove(clientY) {
const rect = this.canvas.getBoundingClientRect();
const scaleY = this.height / rect.height;
let pointerY = (clientY - rect.top) * scaleY;
this.player.y = pointerY - this.player.h / 2;
}
resetBall(scorer) {
if (this.serveTimeoutId) { clearTimeout(this.serveTimeoutId); this.serveTimeoutId = null; }
this.ball.x = this.width / 2 - this.ball.w / 2; this.ball.y = this.height / 2 - this.ball.h / 2;
this.ball.dx = 0; this.ball.dy = 0; this.isServing = true;
const serveDelay = 1500;
this.serveTimeoutId = setTimeout(() => {
if (!this.isRunning) return;
const initialServeSpeed = isMobileDevice() ? 4 : 3;
let direction = (Math.random() > 0.5 ? 1 : -1);
if (scorer === 'ai') direction = -1;
if (scorer === 'player') direction = 1;
this.ball.dx = initialServeSpeed * direction;
this.ball.dy = initialServeSpeed * (Math.random() * 1.4 - 0.7);
this.isServing = false; this.serveTimeoutId = null;
}, serveDelay);
}
resetGame() {
this.player.score = 0; this.ai.score = 0; this.round = 1;
this.adjustDifficulty(); this.updateScoreDisplay(); this.resetBall(null);
}
start() {
if (this.isRunning) return;
this.isRunning = true; this.resizeCanvas(); this.loop();
}
startNewRound() {
if (this.isRunning) return;
this.isRunning = true; this.resizeCanvas(); this.resetBall(null); this.loop();
}
stop() {
this.isRunning = false;
if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); }
if (this.serveTimeoutId) { clearTimeout(this.serveTimeoutId); this.serveTimeoutId = null; }
}
resizeCanvas() {
const container = document.getElementById('miniGamesContainer');
if (!container) return;
const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
const gameAspectRatio = this.width / this.height;
const headerHeight = container.querySelector('.resume-header')?.offsetHeight || 0;
const scoreHeight = document.getElementById('pong-score')?.offsetHeight || 0;
const instructionsHeight = document.getElementById('pong-instructions')?.offsetHeight || 0;
const verticalBuffer = 60;
const availableHeight = containerHeight - (headerHeight + scoreHeight + instructionsHeight + verticalBuffer);
const availableWidth = containerWidth - 40;
let displayWidth = availableWidth;
let displayHeight = displayWidth / gameAspectRatio;
if (displayHeight > availableHeight) {
displayHeight = availableHeight;
displayWidth = displayHeight * gameAspectRatio;
}
this.canvas.style.width = `${displayWidth}px`; this.canvas.style.height = `${displayHeight}px`;
}
updateScoreDisplay() {
document.getElementById('player-score').textContent = this.player.score;
document.getElementById('ai-score').textContent = this.ai.score;
document.getElementById('pong-round').textContent = this.round;
}
checkWinCondition() {
const winningScore = 5; let roundOver = false;
if (this.player.score >= winningScore) {
this.round++; this.showRoundMessage(`You Won Round ${this.round - 1}!`, `AI adapting... (Level ${this.round})`); roundOver = true;
} else if (this.ai.score >= winningScore) {
this.round++; this.showRoundMessage(`AI Won Round ${this.round - 1}!`, `AI learning... (Level ${this.round})`); roundOver = true;
}
if (roundOver) {
this.player.score = 0; this.ai.score = 0;
this.adjustDifficulty(); this.updateScoreDisplay(); this.stop();
}
}
showRoundMessage(line1, line2) {
const msgElement = document.getElementById('pong-round-message');
msgElement.innerHTML = `${line1}<br><small>${line2}</small>`;
msgElement.style.display = 'block';
setTimeout(() => {
msgElement.style.display = 'none';
if (document.getElementById('miniGamesOverlay').style.display !== 'none') { this.startNewRound(); }
}, 3500);
}
update() {
if (this.pongKeys.ArrowUp || this.pongKeys.W) { this.player.y -= this.playerSpeed; }
if (this.pongKeys.ArrowDown || this.pongKeys.S) { this.player.y += this.playerSpeed; }
if (this.player.y < 0) this.player.y = 0;
if (this.player.y + this.player.h > this.height) this.player.y = this.height - this.player.h;
if (this.ball.dx > 0 && (this.ball.dx !== 0 || this.ball.dy !== 0)) {
if (Math.random() < this.aiReactionFrequency) {
let predictedY = this.ball.y;
predictedY += (Math.random() - 0.5) * this.aiErrorMargin;
this.ai.targetY = predictedY - this.ai.h / 2;
}
} else {
if (Math.random() < 0.05) { this.ai.targetY = this.height / 2 - this.ai.h / 2; }
}
if (this.ai.y < this.ai.targetY) {
this.ai.y += Math.min(this.aiBaseSpeed, this.ai.targetY - this.ai.y);
} else if (this.ai.y > this.ai.targetY) {
this.ai.y -= Math.min(this.aiBaseSpeed, this.ai.y - this.ai.targetY);
}
if (this.ai.y < 0) this.ai.y = 0;
if (this.ai.y + this.ai.h > this.height) this.ai.y = this.height - this.ai.h;
if (this.ball.dx === 0 && this.ball.dy === 0) { return; }
this.ball.x += this.ball.dx; this.ball.y += this.ball.dy;
if (this.ball.y <= 0 || this.ball.y + this.ball.h >= this.height) {
this.ball.dy *= -1;
if (this.ball.y <= 0) this.ball.y = 0;
if (this.ball.y + this.ball.h >= this.height) this.ball.y = this.height - this.ball.h;
}
const collision = (paddle, ball) => {
return paddle.x < ball.x + ball.w && paddle.x + paddle.w > ball.x && paddle.y < ball.y + ball.h && paddle.y + paddle.h > ball.y;
};
let paddleHit = null;
if (this.ball.dx < 0 && collision(this.player, this.ball)) {
paddleHit = this.player; this.ball.x = this.player.x + this.player.w;
} else if (this.ball.dx > 0 && collision(this.ai, this.ball)) {
paddleHit = this.ai; this.ball.x = this.ai.x - this.ball.w;
}
if (paddleHit) {
this.isServing = false;
let reflectionSpeed = this.ball.speed;
let collidePoint = (this.ball.y + this.ball.h / 2) - (paddleHit.y + paddleHit.h / 2);
collidePoint = collidePoint / (paddleHit.h / 2);
let angleRad = (Math.PI / 3.5) * collidePoint;
let direction = (paddleHit === this.player) ? 1 : -1;
this.ball.dx = direction * reflectionSpeed * Math.cos(angleRad);
this.ball.dy = reflectionSpeed * Math.sin(angleRad);
}
if (this.ball.x + this.ball.w < 0) {
this.ai.score++; this.updateScoreDisplay(); this.checkWinCondition();
if (this.isRunning) { this.resetBall('ai'); }
} else if (this.ball.x > this.width) {
this.player.score++; this.updateScoreDisplay(); this.checkWinCondition();
if (this.isRunning) { this.resetBall('player'); }
}
}
draw() {
this.ctx.fillStyle = '#000000'; this.ctx.fillRect(0, 0, this.width, this.height);
this.ctx.strokeStyle = '#4a4f63'; this.ctx.lineWidth = 4; this.ctx.setLineDash([10, 15]);
this.ctx.beginPath(); this.ctx.moveTo(this.width / 2, 0); this.ctx.lineTo(this.width / 2, this.height); this.ctx.stroke();
this.ctx.fillStyle = '#9d4edd'; this.ctx.fillRect(this.player.x, this.player.y, this.player.w, this.player.h);
this.ctx.fillStyle = '#e63946'; this.ctx.fillRect(this.ai.x, this.ai.y, this.ai.w, this.ai.h);
if (this.isServing && this.ball.dx === 0 && this.ball.dy === 0) {
if (Math.floor(Date.now() / 200) % 2 === 0) {
this.ctx.fillStyle = '#FFFFFF'; this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.w, this.ball.h);
}
} else {
this.ctx.fillStyle = '#FFFFFF'; this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.w, this.ball.h);
}
}
loop() {
if (!this.isRunning) return;
this.update(); this.draw();
this.animationFrameId = requestAnimationFrame(() => this.loop());
}
}
let pongGame = null;
function init() {
scene = new THREE.Scene();
scene.fog = new THREE.Fog(colors.horizonGlow, 600, 5000);
camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 5000);
cameraRig = new THREE.Object3D();
cameraPitch = new THREE.Object3D();
cameraPitch.add(camera);
cameraRig.add(cameraPitch);
scene.add(cameraRig);
cameraRig.position.set(100, playerHeight, 130);
cameraPitch.rotation.x = -0.12;
cameraRig.rotation.y = -0.50;
renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
const dpr = window.devicePixelRatio || 1;
let effectiveDPR;
if (isIPad()) { effectiveDPR = 1.0; }
else if (isMobileDevice()) { effectiveDPR = Math.min(1.5, dpr); }
else { effectiveDPR = dpr; }
renderer.setPixelRatio(effectiveDPR);
renderer.shadowMap.enabled = !isMobileDevice();
renderer.shadowMap.type = THREE.BasicShadowMap;
document.body.appendChild(renderer.domElement);
setupPostProcessing();
setupLighting();
initCoins();
createSky();
createGround();
createBuilding();
createBillboard();
createParkingLights();
createTunnel();
createTrees();
createStars();
placeCoins();
document.getElementById('coin-counter').textContent = `COINS: 0 / ${TOTAL_COINS}`;
raycaster = new THREE.Raycaster();
mouse = new THREE.Vector2();
setupEventListeners();

// Initialize Chat Interface
initChat();

if (isMobileDevice()) {
document.getElementById('mobile-controls').style.display = 'flex';
requestAnimationFrame(() => {
initJoystick();
if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
setTimeout(() => {
if (joystickManager && joystickManager[0]) { joystickManager[0].trigger('rested'); }
}, 500);
}
});
} else {
initJoystick();
}
animate();
}

function showOverlay(overlayId) {
hideAllOverlays();
const overlay = document.getElementById(overlayId);
if (overlay) {
isSceneActive = false;
overlay.style.display = 'flex';
renderer.domElement.style.pointerEvents = 'none';
document.body.style.cursor = 'default';
document.getElementById('instructions').style.display = 'none';
document.getElementById('mobile-controls').style.display = 'none';
document.getElementById('coin-counter').style.display = 'none';

if (overlayId === 'miniGamesOverlay') {
    if (!pongGame) { pongGame = new PongGame('pong-canvas'); }
    pongGame.resetGame();
    setTimeout(() => { pongGame.start(); }, 50);
}

// ADDITION: Focus the chat input when Ask John overlay is opened
if (overlayId === 'askJohnOverlay') {
    // Ensure chat is initialized (in case init() somehow failed or was slow)
    initChat(); 
    setTimeout(() => {
        document.getElementById('chat-input').focus();
        // Ensure scroll to bottom on open
        const chatWindow = document.getElementById('chat-window');
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }, 100);
}
}
}
function hideAllOverlays() {
if (pongGame && pongGame.isRunning) { pongGame.stop(); }
document.getElementById('pong-round-message').style.display = 'none';
const overlays = document.querySelectorAll('.scene-overlay');
let wasActive = false;
overlays.forEach(overlay => {
if (overlay.style.display !== 'none') { overlay.style.display = 'none'; wasActive = true; }
});
if (wasActive) {
isSceneActive = true;
renderer.domElement.style.pointerEvents = 'auto';
document.body.style.cursor = 'grab';
isDragging = false; lookTouchId = null;
document.getElementById('coin-counter').style.display = 'block';
if (!isMobileDevice()) {
document.getElementById('instructions').style.display = 'block';
} else {
document.getElementById('mobile-controls').style.display = 'flex';
}
}
}
function getPixelSize() {
let targetVerticalResolution;
if (isIPad()) { targetVerticalResolution = 240; }
else if (isMobileDevice()) { targetVerticalResolution = 280; }
else { targetVerticalResolution = 450; }
const effectiveDPR = renderer.getPixelRatio();
const calculatedSize = (window.innerHeight * effectiveDPR) / targetVerticalResolution;
return Math.max(2, calculatedSize);
}
function setupPostProcessing() {
composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
const dpr = renderer.getPixelRatio();
pixelPass = new THREE.ShaderPass({
uniforms: {
tDiffuse: { value: null },
resolution: { value: new THREE.Vector2(window.innerWidth * dpr, window.innerHeight * dpr) },
pixelSize: { value: getPixelSize() }
},
vertexShader: document.getElementById('pixel-vertex-shader').textContent,
fragmentShader: document.getElementById('pixel-fragment-shader').textContent
});
pixelPass.renderToScreen = true;
composer.addPass(pixelPass);
}
let joystickManager = null;
function initJoystick() {
if (!isMobileDevice()) {
if (joystickManager) { joystickManager.destroy(); joystickManager = null; }
return;
}
if (joystickManager) return;
const options = {
zone: document.getElementById('joystick-zone'), mode: 'static',
position: { left: '50%', top: '50%' }, color: 'rgba(255, 255, 255, 0.5)', size: 120,
};
joystickManager = nipplejs.create(options);
joystickManager.on('move', (evt, data) => {
const angle = data.angle.radian;
const force = Math.min(data.force, 1.0);
joystickInput.x = Math.cos(angle) * force;
joystickInput.y = Math.sin(angle) * force;
});
joystickManager.on('end', () => { joystickInput.x = 0; joystickInput.y = 0; });
}

/* ... (Asset creation functions remain unchanged) ... */
// createCoinTexture, createTextTextureSync, initCoins, createCoin, placeCoins, updateCoins, collectCoin, createFirework, startFireworks, updateFireworks, createSky, setupLighting, createTextTexture, createStripedTexture, createTunnelSignTexture, createGrassTexture, createGround, createRoad, createTunnel, createParkingLights, addControllerElements, createBuilding, createWindow, addShirt, addPaper, addThoughtBubble, createAwning, createSign, createBillboard, createBush, createTrees, createStars

function setupEventListeners() {
window.addEventListener('resize', onWindowResize, false);
document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);
renderer.domElement.addEventListener('mousedown', onDesktopDragStart, false);
document.addEventListener('mousemove', onDesktopDragMove, false);
document.addEventListener('mouseup', onDesktopDragEnd, false);
renderer.domElement.addEventListener('click', onMouseClick, false);
renderer.domElement.addEventListener('touchstart', onTouchStart, {passive: false});
document.addEventListener('touchmove', onTouchMove, {passive: false});
document.addEventListener('touchend', onTouchEnd, false);
document.addEventListener('touchcancel', onTouchEnd, false);
document.querySelectorAll('.close-btn').forEach(btn => {
btn.addEventListener('click', hideAllOverlays, false);
});
document.querySelectorAll('.scene-overlay').forEach(overlay => {
overlay.addEventListener('click', function(event) {
if (event.target === this) { hideAllOverlays(); }
}, false);
});
const jumpBtn = document.getElementById('jump-btn');
jumpBtn.addEventListener('touchstart', (e) => {
e.preventDefault(); e.stopPropagation(); keys[' '] = true; jumpBtn.classList.add('active');
});
jumpBtn.addEventListener('touchend', (e) => {
e.preventDefault(); e.stopPropagation(); keys[' '] = false; jumpBtn.classList.remove('active');
});
jumpBtn.addEventListener('mousedown', (e) => e.preventDefault());
}

function onWindowResize() {
// ... (Implementation remains identical to original script)
}

function onKeyDown(event) {
    // MODIFICATION: Prevent key actions if the chat input is focused
    if (document.activeElement.id === 'chat-input') return;

    if (event.key === 'Escape' && !isSceneActive) { hideAllOverlays(); return; }
    if (pongGame && pongGame.isRunning) { return; }
    if (!isSceneActive) return;

    if (keys.hasOwnProperty(event.key.toLowerCase())) {
        keys[event.key.toLowerCase()] = true;
        event.preventDefault();
    }
    if(event.key === ' '){ keys[' '] = true; event.preventDefault(); }
}

function onKeyUp(event) {
// ... (Implementation remains identical to original script)
}
function onDesktopDragStart(event) {
// ... (Implementation remains identical to original script)
}
function onDesktopDragMove(event) {
// ... (Implementation remains identical to original script)
}
function onDesktopDragEnd() {
// ... (Implementation remains identical to original script)
}

function onTouchStart(event) {
    if (!isSceneActive || !isMobileDevice()) return;

    // MODIFICATION: Prevent camera movement if interacting with chat input/button on mobile
    // Check if the touch event originated from the chat input area or its children
    if (document.getElementById('askJohnOverlay').style.display !== 'none') {
        const chatInputArea = document.getElementById('chat-input-area');
        if (chatInputArea.contains(event.target)) {
             // Allow default behavior for input fields (like focusing, selecting text)
             return; 
        }
    }
    
    // ... (Rest of onTouchStart implementation identical to original script)
}

function onTouchMove(event) {
// ... (Implementation remains identical to original script)
}
function onTouchEnd(event) {
// ... (Implementation remains identical to original script)
}
function handleRotation(deltaX, deltaY, speed) {
// ... (Implementation remains identical to original script)
}
function onMouseClick(event) {
// ... (Implementation remains identical to original script)
}
function updatePlayerMovement(delta) {
// ... (Implementation remains identical to original script)
}
function animate() {
// ... (Implementation remains identical to original script)
}

// --- ADDITION: CHAT INTERFACE JAVASCRIPT ---

// !!! IMPORTANT: Verify this URL matches your Cloudflare Worker URL !!!
// Based on your screenshot (johngresh.workers.dev), this is the likely URL for the worker named 'server-backend-4'.
const WORKER_URL = "https://server-backend-4.johngresh.workers.dev/chat";

let chatHistory = [];
let isChatInitialized = false;

function initChat() {
    if (isChatInitialized) return;
    isChatInitialized = true;

    const sendBtn = document.getElementById('send-btn');
    const chatInput = document.getElementById('chat-input');

    sendBtn.addEventListener('click', handleSendMessage);
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleSendMessage();
        }
    });

    // Add initial bot message
    addMessageToChat("Hello! I'm John's AI assistant. Feel free to ask me about his experience, skills, or projects.", 'bot');
}

async function handleSendMessage() {
    const chatInput = document.getElementById('chat-input');
    const message = chatInput.value.trim();

    if (message === '') return;

    // Add user message to UI and history
    addMessageToChat(message, 'user');
    chatHistory.push({ role: "user", content: message });
    chatInput.value = '';

    // Disable input while waiting for response
    toggleInput(false);

    try {
        const response = await fetch(WORKER_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ history: chatHistory }),
        });

        if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}. Check Worker URL.`);
        }

        const data = await response.json();

        if (data.success && data.response) {
            // Add bot response to UI and history
            addMessageToChat(data.response, 'bot');
            chatHistory.push({ role: "assistant", content: data.response });

             // Keep history manageable (e.g., last 10 messages)
            if (chatHistory.length > 10) {
                chatHistory = chatHistory.slice(-10);
            }

        } else {
            throw new Error(data.error || "An unknown error occurred.");
        }

    } catch (error) {
        console.error("Error communicating with backend:", error);
        addMessageToChat(`Error: ${error.message}. Please ensure the backend is running and configured correctly.`, 'bot');
        // If an error occurs, remove the last user message from history so they can retry
        chatHistory.pop();
    } finally {
        // Re-enable input
        toggleInput(true);
    }
}

function addMessageToChat(message, sender) {
    const chatMessages = document.getElementById('chat-messages');
    const chatWindow = document.getElementById('chat-window');
    const messageElement = document.createElement('div');
    messageElement.classList.add('message');

    if (sender === 'user') {
        messageElement.classList.add('user-message');
    } else {
        messageElement.classList.add('bot-message');
    }

    // Basic sanitization of the message content
    messageElement.textContent = message;
    chatMessages.appendChild(messageElement);

    // Scroll to the bottom of the chat window
    // Use behavior: 'smooth' for a nicer effect
    chatWindow.scrollTo({ top: chatWindow.scrollHeight, behavior: 'smooth' });
}

function toggleInput(enabled) {
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');

    chatInput.disabled = !enabled;
    sendBtn.disabled = !enabled;

    if (enabled) {
        chatInput.focus();
        chatInput.placeholder = "Type your question...";
    } else {
        // Add a visual indication that the bot is thinking
        chatInput.placeholder = "Thinking...";
    }
}

// --- END CHAT INTERFACE JAVASCRIPT ---


document.fonts.ready.then(() => {
init();
}).catch((error) => {
console.error("Error loading fonts:", error);
init();
});
</script>
</body>
</html>
