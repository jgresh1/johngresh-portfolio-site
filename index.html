<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>John Gresh : Portfolio Web Game</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
body { margin: 0; overflow: hidden; background-color: #000; cursor: grab; -webkit-overflow-scrolling: touch; overscroll-behavior: none; }
canvas { display: block; touch-action: none; }
#instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255, 255, 255, 0.9); font-family: 'VT323', monospace; font-size: 18px; text-shadow: 2px 2px 4px black; pointer-events: none; text-align: center; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 0; z-index: 10; }
#coin-counter { position: absolute; top: 20px; right: 20px; color: #ffd700; font-family: 'VT323', monospace; font-size: 36px; text-shadow: 3px 3px 0px black; padding: 10px 20px; background: rgba(26, 5, 58, 0.8); border: 4px solid black; z-index: 15; display: block; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); pointer-events: none; }
.scene-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(26, 5, 58, 0.9); z-index: 1000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(3px); }
.overlay-container { width: 85%; max-width: 1100px; height: 85vh; overflow-y: auto; padding: 30px; border: 4px solid #000; box-shadow: 0 0 50px rgba(255, 125, 92, 0.9); background-color: #1a1a2e; color: #ffffff; font-family: 'VT323', monospace; line-height: 1.3; }
#tshirtsContainer, #askJohnContainer { max-width: 650px; height: auto; max-height: 85vh; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
#tshirtsContainer { box-shadow: 0 0 50px rgba(0, 119, 182, 0.9); }
#askJohnContainer { box-shadow: 0 0 50px rgba(255, 167, 0, 0.9); }
#miniGamesContainer { box-shadow: 0 0 50px rgba(106, 13, 173, 0.9); display: flex; flex-direction: column; justify-content: flex-start; align-items: center; text-align: center; }
.close-btn { position: fixed; top: 20px; right: 20px; padding: 10px 20px; font-size: 24px; font-family: 'VT323', monospace; background-color: #e63946; color: white; border: 3px solid black; cursor: pointer; border-radius: 0; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s; z-index: 1001; }
.close-btn:hover { background-color: #ff5a5f; }
.close-btn:active { transform: translate(3px, 3px); box-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
.overlay-container::-webkit-scrollbar { width: 14px; }
.overlay-container::-webkit-scrollbar-track { background: #2a1a3d; border-left: 2px solid black; }
.overlay-container::-webkit-scrollbar-thumb { background: #6c6383; border: 2px solid black; border-radius: 0; }
.overlay-container::-webkit-scrollbar-thumb:hover { background: #8a505d; }
.resume-header { text-align: center; margin-bottom: 30px; border-bottom: 4px dashed #6c6383; padding-bottom: 20px; width: 100%; }
.resume-header h1 { font-size: 48px; margin: 0; color: #ff7d5c; text-shadow: 3px 3px 0px rgba(0,0,0,0.5); }
#tshirtsContainer .resume-header h1 { color: #0077b6; }
#askJohnContainer .resume-header h1 { color: #ffa700; }
#miniGamesContainer .resume-header h1 { color: #9d4edd; }
.resume-header p { font-size: 22px; margin: 5px 0 0 0; color: #d4a3a3; }
.resume-section { margin-bottom: 30px; }
.resume-section h2 { font-size: 30px; color: #2a9d8f; border-bottom: 2px solid #2a9d8f; padding-bottom: 5px; margin-bottom: 15px; text-transform: uppercase; }
.job, .education-item { margin-bottom: 20px; padding-left: 10px; }
.job-title, .degree-title { font-size: 26px; color: #e63946; }
.company, .school { font-size: 22px; color: #ffffff; }
.dates { font-size: 20px; color: #a37c7c; display: block; margin-bottom: 8px; }
.responsibilities, .skills-list { font-size: 21px; list-style: none; padding: 0; margin: 0; color: #fdf6e3; }
.responsibilities li:before, .skills-list li:before { content: '>'; position: absolute; left: 0; color: #0077b6; }
.resume-layout { display: flex; flex-wrap: wrap; gap: 30px; }
.layout-main { flex: 2; min-width: 300px; }
.layout-sidebar { flex: 1; min-width: 250px; }
.progress-container { width: 90%; background-color: #2a1a3d; border: 4px solid #000; margin: 25px 0; box-shadow: 5px 5px 0px rgba(0,0,0,0.8); }
.progress-bar { background-color: #0077b6; height: 35px; width: 60%; background-image: linear-gradient(90deg, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.25) 5%, transparent 5%, transparent 100%); background-size: 20px 100%; }
#askJohnContainer .progress-bar { background-color: #ffa700; width: 50%; }
#miniGamesContainer .progress-bar { background-color: #6a0dad; width: 30%; }
.loading-text { font-size: 28px; color: #ffffff; margin-top: 15px; }
#mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 200px; z-index: 20; display: none; justify-content: space-between; align-items: center; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
#joystick-zone { position: relative; width: 150px; height: 150px; pointer-events: auto; margin-left: 20px; touch-action: none; }
#action-buttons { display: flex; gap: 20px; pointer-events: auto; margin-right: 40px; touch-action: none; }
.action-btn { width: 90px; height: 90px; border-radius: 50%; background: rgba(255, 69, 0, 0.5); border: 3px solid rgba(255, 255, 255, 0.7); color: white; font-family: 'VT323', monospace; font-size: 24px; display: flex; justify-content: center; align-items: center; user-select: none; transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s; }
.action-btn:active, .action-btn.active { background: rgba(255, 69, 0, 0.8); transform: scale(0.95); }
#pong-canvas { background-color: #000; border: 4px solid #9d4edd; display: block; margin: 0 auto 20px auto; cursor: ns-resize; touch-action: none; }
#pong-score { font-size: 36px; color: #fff; text-align: center; margin-bottom: 15px; }
#pong-instructions { text-align: center; font-size: 20px; margin-top: 5px; color: #d4a3a3; padding-bottom: 20px; }
#pong-round-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 36px; color: #ff7d5c; background-color: rgba(26, 5, 58, 0.95); padding: 20px 40px; border: 3px solid #ff7d5c; display: none; z-index: 1002; text-align: center; white-space: nowrap; box-shadow: 0 0 30px rgba(255, 125, 92, 0.7); }
@media (max-width: 800px) {
#instructions { display: none; }
#coin-counter { font-size: 20px; top: 10px; right: 10px; padding: 4px 8px; }
.close-btn { top: 10px; right: 10px; padding: 8px 16px; font-size: 20px; border: 3px solid black; box-shadow: 3px 3px 0px rgba(0,0,0,0.8); }
.close-btn:active { transform: translate(1px, 1px); box-shadow: 1px 1px 0px rgba(0,0,0,0.8); }
.overlay-container { margin-top: 60px; height: calc(100vh - 80px); max-height: none; width: 95%; padding: 15px; }
.resume-header h1 { font-size: 36px; }
#pong-score { font-size: 28px; }
#pong-round-message { font-size: 24px; padding: 15px 25px; white-space: normal; }
}
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {
.close-btn { position: fixed !important; z-index: 1001 !important; top: 15px !important; right: 15px !important; padding: 12px 24px !important; font-size: 26px !important; background-color: #e63946 !important; border: 4px solid black !important; }
.overlay-container { margin-top: 80px !important; height: calc(100vh - 100px) !important; max-height: none !important; }
}
</style>
</head>
<body>
<div id="instructions">WASD/Arrows: Move | Space: Jump | Drag: Look<br>Click the store signs. Find the hidden coins!</div>
<div id="coin-counter">COINS: 0 / 6</div>
<div id="resumeOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="resumeContainer" class="overlay-container">
<div class="resume-header"><h1>John Gresh</h1><p>(336) 995-4119 | johngresh.usa@gmail.com</p></div>
<div class="resume-layout">
<div class="layout-main">
<section class="resume-section">
<h2>Experience</h2>
<div class="job"><div class="job-title">Maintenance Technician</div><div class="company">Toyota Battery Factory</div><span class="dates">July 2024 - November 2024</span>
<ul class="responsibilities"><li>General Maintenance</li><li>Preventative Maintenance</li><li>Work orders/Cost Center Management</li><li>Performing Job Safety Analysis</li></ul>
</div>
<div class="job"><div class="job-title">Assistant Manager</div><div class="company">New Balance</div><span class="dates">October 2021 - Current</span>
<ul class="responsibilities"><li>Assisting in the general operation of the store</li><li>Opening and closing the store</li><li>Overseeing the customer experience</li><li>Fitting customers for shoes</li></ul>
</div>
<div class="job"><div class="job-title">Sales Representative</div><div class="company">GNC</div><span class="dates">March 2019 - July 2019, Charlotte NC</span>
<ul class="responsibilities"><li>Opening/Closing store</li><li>Inventory checks</li><li>Customer relations</li><li>Register</li><li>Cleaning</li></ul>
</div>
<div class="job"><div class="job-title">Lifeguard</div><div class="company">Forsyth Country Club</div><span class="dates">2016 - 2017 Summer</span>
<ul class="responsibilities"><li>Lifeguarding</li><li>Checking in guests</li><li>Cleaning pool deck and pool services</li><li>Testing pool chemicals/Adding chemicals</li><li>Strong emphasis on customer relations</li></ul>
</div>
<div class="job"><div class="job-title">Bussing tables / working in kitchen</div><div class="company">Vincenzo's Restaurant</div><span class="dates">January 2015 - December 2015, Winston-salem NC</span>
<ul class="responsibilities"><li>Making bread/Cleaning dishes/Making salads/ Bus Boy</li><li>Cleaning station</li><li>Customer relations</li></ul>
</div>
</section>
</div>
<div class="layout-sidebar">
<section class="resume-section">
<h2>Education</h2>
<div class="education-item"><div class="degree-title">Mechatronics Technician</div><div class="school">Forsyth Tech</div><span class="dates">August 2022 - May 2024, Winston Salem NC</span></div>
<div class="education-item"><div class="degree-title">Internship</div><div class="school">ThinkPLC</div><span class="dates">August 2022 - May 2023, Winston Salem NC</span></div>
<div class="education-item"><div class="degree-title">High School Diploma</div><div class="school">Mount Tabor</div><span class="dates">August 2013 - May 2017, Winston Salem NC</span></div>
</section>
<section class="resume-section">
<h2>Skills</h2>
<ul class="skills-list">
<li>OSHA 10-Hr Certified</li><li>Electrical Safe Work Practices Certified</li><li>Control of Hazardous Energy Certified</li><li>PLC installation / proficient</li><li>PLC programming (RSLogix) / proficient</li><li>Python / proficient</li><li>C++ / beginner</li><li>Matlab / beginner</li><li>Sales experience (GNC, New Balance)</li><li>Cell phone and electronic repair (iPhone/Mac)</li>
</ul>
</section>
</div>
</div>
</div>
</div>
<div id="projectsOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="projectsContainer" class="overlay-container">
<div class="resume-header"><h1>Projects</h1></div>
<section class="resume-section"><h2>Featured Work</h2><ul class="skills-list"><li>This Website</li></ul></section>
</div>
</div>
<div id="tshirtsOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="tshirtsContainer" class="overlay-container">
<div class="resume-header"><h1>T-Shirt Store (WIP)</h1></div>
<p class="loading-text">Initializing Storefront...</p>
<div class="progress-container"><div class="progress-bar"></div></div>
<p class="loading-text">> later this week</p>
</div>
</div>
<div id="askJohnOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="askJohnContainer" class="overlay-container">
<div class="resume-header"><h1>Ask John (WIP)</h1></div>
<p class="loading-text">Loading...</p>
<div class="progress-container"><div class="progress-bar"></div></div>
<p class="loading-text">> Coming Soon</p>
</div>
</div>
<div id="miniGamesOverlay" class="scene-overlay">
<button class="close-btn">[X] BACK</button>
<div id="miniGamesContainer" class="overlay-container">
<div class="resume-header"><h1>Pong AI</h1></div>
<div id="pong-score">Player: <span id="player-score">0</span> | AI: <span id="ai-score">0</span> | Round: <span id="pong-round">1</span></div>
<canvas id="pong-canvas"></canvas>
<div id="pong-instructions">
<p>First to 5 wins the round. The AI adapts each round!</p>
<p>Desktop: Use Mouse or W/S/Up/Down Arrows.</p>
<p>Mobile: Drag your paddle.</p>
</div>
</div>
</div>
<div id="pong-round-message"></div>
<div id="mobile-controls"><div id="joystick-zone"></div><div id="action-buttons"><div id="jump-btn" class="action-btn">JUMP</div></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
<script id="pixel-vertex-shader" type="x-shader/x-vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</script>
<script id="pixel-fragment-shader" type="x-shader/x-fragment">uniform sampler2D tDiffuse; uniform vec2 resolution; uniform float pixelSize; varying vec2 vUv; void main() { vec2 dxy = pixelSize / resolution; vec2 coord = dxy * floor(vUv / dxy + 0.5); gl_FragColor = texture2D(tDiffuse, coord); }</script>
<script id="sky-vertex-shader" type="x-shader/x-vertex">varying vec3 vWorldPosition; void main() { vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</script>
<script id="sky-fragment-shader" type="x-shader/x-fragment">
uniform vec3 colorZenith; uniform vec3 colorHorizonBright; uniform vec3 colorHorizonDark; uniform vec3 sunDirection; varying vec3 vWorldPosition;
void main() {
vec3 direction = normalize(vWorldPosition); float h = max(0.0, direction.y);
float verticalFade = pow(1.0 - h, 2.5);
float sunAlignment = dot(direction, sunDirection); float horizontalFactor = (sunAlignment + 1.0) * 0.5;
horizontalFactor = smoothstep(0.3, 0.7, horizontalFactor);
vec3 baseHorizonColor = mix(colorHorizonDark, colorHorizonBright, horizontalFactor);
vec3 skyColor = mix(colorZenith, baseHorizonColor, verticalFade);
float sunHotspot = max(0.0, sunAlignment); sunHotspot = pow(sunHotspot, 32.0);
vec3 hotspotColor = vec3(1.0, 0.9, 0.7); skyColor += hotspotColor * sunHotspot * 0.8;
gl_FragColor = vec4(skyColor, 1.0);
}
</script>
<script>
let scene, camera, renderer, composer, pixelPass;
let cameraRig, cameraPitch;
let raycaster, mouse;
const clickableObjects = [];
const clock = new THREE.Clock();
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, s: false, d: false, ' ': false };
let joystickInput = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let lookTouchId = null;
let isSceneActive = true;
const coins = [];
let coinsCollected = 0;
const TOTAL_COINS = 6;
let coinGeometry, coinMaterials;
const fireworks = [];
let fireworkTimer = null;
const playerHeight = 10;
let isJumping = false;
let yVelocity = 0;
const gravity = -80;
const jumpForce = 30;
const ROAD_CONFIG = { width: 36, length: 1500, startZ: 260, shoulderWidth: 10 };
ROAD_CONFIG.endZ = ROAD_CONFIG.startZ + ROAD_CONFIG.length;
const TUNNEL_CONFIG = { startZ: 350, length: 500, width: 50, height: 35, wallThickness: 10, clearanceWidth: 180 };
TUNNEL_CONFIG.endZ = TUNNEL_CONFIG.startZ + TUNNEL_CONFIG.length;
const colors = {
skyZenith: 0x1a053a, skyHorizonDark: 0x2a1a3d, horizonGlow: 0xff7d5c, asphalt: 0x1a1a2e, asphaltLine: 0x6c6383,
brick: 0x8a505d, grass: 0x182c25, stucco: 0xd4a3a3, stuccoDark: 0xa37c7c, windowGlowBright: 0xfff5c3,
windowGlowDim: 0x839db5, signResume: 0xe63946, signTshirts: 0x0077b6, signProjects: 0x2a9d8f, signAskJohn: 0xffa700,
signMiniGames: 0x6a0dad,
billboardGlow: 0xffe8a3, billboardText: 0xd95763, treeDark: 0x1b3028, treeTrunk: 0x4a3f35, metalDark: 0x1a1a2e,
poleMetal: 0x4a4f63, poleGlow: 0xffe0a3, coinGold: 0xffd700, coinDarkGold: 0xc6a100, tunnelConcrete: 0x3a3a4a,
tunnelFacade: 0x5a5a6a, tunnelLight: 0xffa050
};
const sunDirectionVector = new THREE.Vector3(-1, 0.25, -0.8).normalize();

function isMobileDevice() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800; }
function isIPad() { return /iPad/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

class PongGame {
constructor(canvasId) {
this.canvas = document.getElementById(canvasId);
this.ctx = this.canvas.getContext('2d');
this.isRunning = false; this.animationFrameId = null; this.isServing = false; this.serveTimeoutId = null;
this.width = 640; this.height = 400;
this.canvas.width = this.width; this.canvas.height = this.height;
this.paddleWidth = 10; this.paddleHeight = 80; this.playerSpeed = 8; this.ballSize = 10;
this.baseBallSpeed = isMobileDevice() ? 6 : 5;
this.round = 1; this.aiBaseSpeed = 4; this.aiReactionFrequency = 0.1; this.aiErrorMargin = 35;
this.player = { x: this.paddleWidth, y: this.height / 2 - this.paddleHeight / 2, w: this.paddleWidth, h: this.paddleHeight, score: 0 };
this.ai = { x: this.width - this.paddleWidth * 2, y: this.height / 2 - this.paddleHeight / 2, w: this.paddleWidth, h: this.paddleHeight, score: 0, targetY: this.height / 2 };
this.ball = { x: this.width / 2, y: this.height / 2, w: this.ballSize, h: this.ballSize, dx: 0, dy: 0, speed: this.baseBallSpeed };
this.pongKeys = { ArrowUp: false, ArrowDown: false, W: false, S: false };
this.isDraggingPaddle = false;
this.setupEventListeners();
this.resetGame();
}
adjustDifficulty() {
this.aiBaseSpeed = 4 + this.round * 0.5;
this.aiReactionFrequency = Math.min(0.9, 0.1 + this.round * 0.08);
this.aiErrorMargin = Math.max(5, 35 - this.round * 4);
this.ball.speed = this.baseBallSpeed + this.round * 0.3;
}
setupEventListeners() {
document.addEventListener('keydown', (e) => {
if (this.isRunning) {
if (e.key === 'ArrowUp') { this.pongKeys.ArrowUp = true; e.preventDefault(); }
if (e.key === 'ArrowDown') { this.pongKeys.ArrowDown = true; e.preventDefault(); }
if (e.key === 'w' || e.key === 'W') { this.pongKeys.W = true; e.preventDefault(); }
if (e.key === 's' || e.key === 'S') { this.pongKeys.S = true; e.preventDefault(); }
}
});
document.addEventListener('keyup', (e) => {
if (e.key === 'ArrowUp') this.pongKeys.ArrowUp = false;
if (e.key === 'ArrowDown') this.pongKeys.ArrowDown = false;
if (e.key === 'w' || e.key === 'W') this.pongKeys.W = false;
if (e.key === 's' || e.key === 'S') this.pongKeys.S = false;
});
this.canvas.addEventListener('mousemove', (e) => {
if (this.isRunning && !isMobileDevice()) { this.handlePointerMove(e.clientY); }
});
this.canvas.addEventListener('touchstart', (e) => {
if (this.isRunning) { e.preventDefault(); this.isDraggingPaddle = true; this.handlePointerMove(e.touches[0].clientY); }
}, { passive: false });
this.canvas.addEventListener('touchmove', (e) => {
if (this.isRunning && this.isDraggingPaddle) { e.preventDefault(); this.handlePointerMove(e.touches[0].clientY); }
}, { passive: false });
this.canvas.addEventListener('touchend', (e) => { this.isDraggingPaddle = false; });
}
handlePointerMove(clientY) {
const rect = this.canvas.getBoundingClientRect();
const scaleY = this.height / rect.height;
let pointerY = (clientY - rect.top) * scaleY;
this.player.y = pointerY - this.player.h / 2;
}
resetBall(scorer) {
if (this.serveTimeoutId) { clearTimeout(this.serveTimeoutId); this.serveTimeoutId = null; }
this.ball.x = this.width / 2 - this.ball.w / 2; this.ball.y = this.height / 2 - this.ball.h / 2;
this.ball.dx = 0; this.ball.dy = 0; this.isServing = true;
const serveDelay = 1500;
this.serveTimeoutId = setTimeout(() => {
if (!this.isRunning) return;
const initialServeSpeed = isMobileDevice() ? 4 : 3;
let direction = (Math.random() > 0.5 ? 1 : -1);
if (scorer === 'ai') direction = -1;
if (scorer === 'player') direction = 1;
this.ball.dx = initialServeSpeed * direction;
this.ball.dy = initialServeSpeed * (Math.random() * 1.4 - 0.7);
this.isServing = false; this.serveTimeoutId = null;
}, serveDelay);
}
resetGame() {
this.player.score = 0; this.ai.score = 0; this.round = 1;
this.adjustDifficulty(); this.updateScoreDisplay(); this.resetBall(null);
}
start() {
if (this.isRunning) return;
this.isRunning = true; this.resizeCanvas(); this.loop();
}
startNewRound() {
if (this.isRunning) return;
this.isRunning = true; this.resizeCanvas(); this.resetBall(null); this.loop();
}
stop() {
this.isRunning = false;
if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); }
if (this.serveTimeoutId) { clearTimeout(this.serveTimeoutId); this.serveTimeoutId = null; }
}
resizeCanvas() {
const container = document.getElementById('miniGamesContainer');
if (!container) return;
const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
const gameAspectRatio = this.width / this.height;
const headerHeight = container.querySelector('.resume-header')?.offsetHeight || 0;
const scoreHeight = document.getElementById('pong-score')?.offsetHeight || 0;
const instructionsHeight = document.getElementById('pong-instructions')?.offsetHeight || 0;
const verticalBuffer = 60;
const availableHeight = containerHeight - (headerHeight + scoreHeight + instructionsHeight + verticalBuffer);
const availableWidth = containerWidth - 40;
let displayWidth = availableWidth;
let displayHeight = displayWidth / gameAspectRatio;
if (displayHeight > availableHeight) {
displayHeight = availableHeight;
displayWidth = displayHeight * gameAspectRatio;
}
this.canvas.style.width = `${displayWidth}px`; this.canvas.style.height = `${displayHeight}px`;
}
updateScoreDisplay() {
document.getElementById('player-score').textContent = this.player.score;
document.getElementById('ai-score').textContent = this.ai.score;
document.getElementById('pong-round').textContent = this.round;
}
checkWinCondition() {
const winningScore = 5; let roundOver = false;
if (this.player.score >= winningScore) {
this.round++; this.showRoundMessage(`You Won Round ${this.round - 1}!`, `AI adapting... (Level ${this.round})`); roundOver = true;
} else if (this.ai.score >= winningScore) {
this.round++; this.showRoundMessage(`AI Won Round ${this.round - 1}!`, `AI learning... (Level ${this.round})`); roundOver = true;
}
if (roundOver) {
this.player.score = 0; this.ai.score = 0;
this.adjustDifficulty(); this.updateScoreDisplay(); this.stop();
}
}
showRoundMessage(line1, line2) {
const msgElement = document.getElementById('pong-round-message');
msgElement.innerHTML = `${line1}<br><small>${line2}</small>`;
msgElement.style.display = 'block';
setTimeout(() => {
msgElement.style.display = 'none';
if (document.getElementById('miniGamesOverlay').style.display !== 'none') { this.startNewRound(); }
}, 3500);
}
update() {
if (this.pongKeys.ArrowUp || this.pongKeys.W) { this.player.y -= this.playerSpeed; }
if (this.pongKeys.ArrowDown || this.pongKeys.S) { this.player.y += this.playerSpeed; }
if (this.player.y < 0) this.player.y = 0;
if (this.player.y + this.player.h > this.height) this.player.y = this.height - this.player.h;
if (this.ball.dx > 0 && (this.ball.dx !== 0 || this.ball.dy !== 0)) {
if (Math.random() < this.aiReactionFrequency) {
let predictedY = this.ball.y;
predictedY += (Math.random() - 0.5) * this.aiErrorMargin;
this.ai.targetY = predictedY - this.ai.h / 2;
}
} else {
if (Math.random() < 0.05) { this.ai.targetY = this.height / 2 - this.ai.h / 2; }
}
if (this.ai.y < this.ai.targetY) {
this.ai.y += Math.min(this.aiBaseSpeed, this.ai.targetY - this.ai.y);
} else if (this.ai.y > this.ai.targetY) {
this.ai.y -= Math.min(this.aiBaseSpeed, this.ai.y - this.ai.targetY);
}
if (this.ai.y < 0) this.ai.y = 0;
if (this.ai.y + this.ai.h > this.height) this.ai.y = this.height - this.ai.h;
if (this.ball.dx === 0 && this.ball.dy === 0) { return; }
this.ball.x += this.ball.dx; this.ball.y += this.ball.dy;
if (this.ball.y <= 0 || this.ball.y + this.ball.h >= this.height) {
this.ball.dy *= -1;
if (this.ball.y <= 0) this.ball.y = 0;
if (this.ball.y + this.ball.h >= this.height) this.ball.y = this.height - this.ball.h;
}
const collision = (paddle, ball) => {
return paddle.x < ball.x + ball.w && paddle.x + paddle.w > ball.x && paddle.y < ball.y + ball.h && paddle.y + paddle.h > ball.y;
};
let paddleHit = null;
if (this.ball.dx < 0 && collision(this.player, this.ball)) {
paddleHit = this.player; this.ball.x = this.player.x + this.player.w;
} else if (this.ball.dx > 0 && collision(this.ai, this.ball)) {
paddleHit = this.ai; this.ball.x = this.ai.x - this.ball.w;
}
if (paddleHit) {
this.isServing = false;
let reflectionSpeed = this.ball.speed;
let collidePoint = (this.ball.y + this.ball.h / 2) - (paddleHit.y + paddleHit.h / 2);
collidePoint = collidePoint / (paddleHit.h / 2);
let angleRad = (Math.PI / 3.5) * collidePoint;
let direction = (paddleHit === this.player) ? 1 : -1;
this.ball.dx = direction * reflectionSpeed * Math.cos(angleRad);
this.ball.dy = reflectionSpeed * Math.sin(angleRad);
}
if (this.ball.x + this.ball.w < 0) {
this.ai.score++; this.updateScoreDisplay(); this.checkWinCondition();
if (this.isRunning) { this.resetBall('ai'); }
} else if (this.ball.x > this.width) {
this.player.score++; this.updateScoreDisplay(); this.checkWinCondition();
if (this.isRunning) { this.resetBall('player'); }
}
}
draw() {
this.ctx.fillStyle = '#000000'; this.ctx.fillRect(0, 0, this.width, this.height);
this.ctx.strokeStyle = '#4a4f63'; this.ctx.lineWidth = 4; this.ctx.setLineDash([10, 15]);
this.ctx.beginPath(); this.ctx.moveTo(this.width / 2, 0); this.ctx.lineTo(this.width / 2, this.height); this.ctx.stroke();
this.ctx.fillStyle = '#9d4edd'; this.ctx.fillRect(this.player.x, this.player.y, this.player.w, this.player.h);
this.ctx.fillStyle = '#e63946'; this.ctx.fillRect(this.ai.x, this.ai.y, this.ai.w, this.ai.h);
if (this.isServing && this.ball.dx === 0 && this.ball.dy === 0) {
if (Math.floor(Date.now() / 200) % 2 === 0) {
this.ctx.fillStyle = '#FFFFFF'; this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.w, this.ball.h);
}
} else {
this.ctx.fillStyle = '#FFFFFF'; this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.w, this.ball.h);
}
}
loop() {
if (!this.isRunning) return;
this.update(); this.draw();
this.animationFrameId = requestAnimationFrame(() => this.loop());
}
}
let pongGame = null;
function init() {
scene = new THREE.Scene();
scene.fog = new THREE.Fog(colors.horizonGlow, 600, 5000);
camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 5000);
cameraRig = new THREE.Object3D();
cameraPitch = new THREE.Object3D();
cameraPitch.add(camera);
cameraRig.add(cameraPitch);
scene.add(cameraRig);
cameraRig.position.set(100, playerHeight, 130);
cameraPitch.rotation.x = -0.12;
cameraRig.rotation.y = -0.50;
renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
const dpr = window.devicePixelRatio || 1;
let effectiveDPR;
if (isIPad()) { effectiveDPR = 1.0; }
else if (isMobileDevice()) { effectiveDPR = Math.min(1.5, dpr); }
else { effectiveDPR = dpr; }
renderer.setPixelRatio(effectiveDPR);
renderer.shadowMap.enabled = !isMobileDevice();
renderer.shadowMap.type = THREE.BasicShadowMap;
document.body.appendChild(renderer.domElement);
setupPostProcessing();
setupLighting();
initCoins();
createSky();
createGround();
createBuilding();
createBillboard();
createParkingLights();
createTunnel();
createTrees();
createStars();
placeCoins();
document.getElementById('coin-counter').textContent = `COINS: 0 / ${TOTAL_COINS}`;
raycaster = new THREE.Raycaster();
mouse = new THREE.Vector2();
setupEventListeners();
if (isMobileDevice()) {
document.getElementById('mobile-controls').style.display = 'flex';
requestAnimationFrame(() => {
initJoystick();
if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
setTimeout(() => {
if (joystickManager && joystickManager[0]) { joystickManager[0].trigger('rested'); }
}, 500);
}
});
} else {
initJoystick();
}
animate();
}
function showOverlay(overlayId) {
hideAllOverlays();
const overlay = document.getElementById(overlayId);
if (overlay) {
isSceneActive = false;
overlay.style.display = 'flex';
renderer.domElement.style.pointerEvents = 'none';
document.body.style.cursor = 'default';
document.getElementById('instructions').style.display = 'none';
document.getElementById('mobile-controls').style.display = 'none';
document.getElementById('coin-counter').style.display = 'none';
if (overlayId === 'miniGamesOverlay') {
if (!pongGame) { pongGame = new PongGame('pong-canvas'); }
pongGame.resetGame();
setTimeout(() => { pongGame.start(); }, 50);
}
}
}
function hideAllOverlays() {
if (pongGame && pongGame.isRunning) { pongGame.stop(); }
document.getElementById('pong-round-message').style.display = 'none';
const overlays = document.querySelectorAll('.scene-overlay');
let wasActive = false;
overlays.forEach(overlay => {
if (overlay.style.display !== 'none') { overlay.style.display = 'none'; wasActive = true; }
});
if (wasActive) {
isSceneActive = true;
renderer.domElement.style.pointerEvents = 'auto';
document.body.style.cursor = 'grab';
isDragging = false; lookTouchId = null;
document.getElementById('coin-counter').style.display = 'block';
if (!isMobileDevice()) {
document.getElementById('instructions').style.display = 'block';
} else {
document.getElementById('mobile-controls').style.display = 'flex';
}
}
}
function getPixelSize() {
let targetVerticalResolution;
if (isIPad()) { targetVerticalResolution = 240; }
else if (isMobileDevice()) { targetVerticalResolution = 280; }
else { targetVerticalResolution = 450; }
const effectiveDPR = renderer.getPixelRatio();
const calculatedSize = (window.innerHeight * effectiveDPR) / targetVerticalResolution;
return Math.max(2, calculatedSize);
}
function setupPostProcessing() {
composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
const dpr = renderer.getPixelRatio();
pixelPass = new THREE.ShaderPass({
uniforms: {
tDiffuse: { value: null },
resolution: { value: new THREE.Vector2(window.innerWidth * dpr, window.innerHeight * dpr) },
pixelSize: { value: getPixelSize() }
},
vertexShader: document.getElementById('pixel-vertex-shader').textContent,
fragmentShader: document.getElementById('pixel-fragment-shader').textContent
});
pixelPass.renderToScreen = true;
composer.addPass(pixelPass);
}
let joystickManager = null;
function initJoystick() {
if (!isMobileDevice()) {
if (joystickManager) { joystickManager.destroy(); joystickManager = null; }
return;
}
if (joystickManager) return;
const options = {
zone: document.getElementById('joystick-zone'), mode: 'static',
position: { left: '50%', top: '50%' }, color: 'rgba(255, 255, 255, 0.5)', size: 120,
};
joystickManager = nipplejs.create(options);
joystickManager.on('move', (evt, data) => {
const angle = data.angle.radian;
const force = Math.min(data.force, 1.0);
joystickInput.x = Math.cos(angle) * force;
joystickInput.y = Math.sin(angle) * force;
});
joystickManager.on('end', () => { joystickInput.x = 0; joystickInput.y = 0; });
}
function createCoinTexture(size = 128) {
const canvas = document.createElement('canvas');
canvas.width = size; canvas.height = size;
const context = canvas.getContext('2d');
context.fillStyle = new THREE.Color(colors.coinGold).getStyle();
context.fillRect(0, 0, size, size);
context.strokeStyle = new THREE.Color(colors.coinDarkGold).getStyle();
context.lineWidth = size * 0.08;
context.beginPath();
context.arc(size / 2, size / 2, size / 2 - context.lineWidth/2, 0, Math.PI * 2, true);
context.stroke();
context.font = `bold ${size * 0.6}px 'VT323', monospace`;
context.textAlign = 'center'; context.textBaseline = 'middle';
context.fillStyle = new THREE.Color(colors.coinDarkGold).getStyle();
context.fillText('$', size / 2, size / 2 + size * 0.05);
const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function createTextTextureSync(text, color, fontSize = 24, bgColor = null) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = 64; canvas.height = 64;
if (bgColor) {
context.fillStyle = bgColor;
context.fillRect(0, 0, canvas.width, canvas.height);
}
context.font = `${fontSize}px 'VT323', monospace`;
context.textAlign = 'center'; context.textBaseline = 'middle';
context.fillStyle = color;
context.fillText(text, canvas.width / 2, canvas.height / 2 + fontSize * 0.1);
const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function initCoins() {
const segments = isMobileDevice() ? 8 : 12;
coinGeometry = new THREE.CylinderGeometry(2, 2, 0.6, segments);
const sideMaterial = new THREE.MeshStandardMaterial({ color: colors.coinGold, metalness: 0.8, roughness: 0.5, emissive: 0x4a2d00 });
const coinFaceTexture = createCoinTexture(128);
coinFaceTexture.rotation = Math.PI / 2;
coinFaceTexture.center.set(0.5, 0.5);
const faceMaterial = new THREE.MeshStandardMaterial({ map: coinFaceTexture, metalness: 0.8, roughness: 0.3, emissive: 0x4a2d00 });
coinMaterials = [sideMaterial, faceMaterial, faceMaterial];
}
function createCoin(x, y, z) {
const coin = new THREE.Mesh(coinGeometry, coinMaterials);
coin.position.set(x, y, z);
coin.rotation.x = Math.PI / 2;
if (renderer.shadowMap.enabled) { coin.castShadow = true; }
scene.add(coin);
coins.push({ mesh: coin, collected: false, startY: y });
}
function placeCoins() {
const coinHeight = 6.5;
createCoin(80, coinHeight, 100);
createCoin(0, coinHeight - 2.5, -18);
createCoin(-200, coinHeight, 200);
createCoin(30, coinHeight, TUNNEL_CONFIG.startZ - 20);
createCoin(0, coinHeight, TUNNEL_CONFIG.startZ + TUNNEL_CONFIG.length / 2);
createCoin(-45, coinHeight, -35);
}
function updateCoins(delta, time) {
const rotationSpeed = 1.5; const hoverSpeed = 1.8; const hoverHeight = 0.3;
const collectionDistance = 8;
const playerPosition = cameraRig.position;
coins.forEach(coinData => {
if (!coinData.collected) {
const coin = coinData.mesh;
coin.rotation.z += rotationSpeed * delta;
const timeOffset = coinData.startY + coin.position.x + coin.position.z;
coin.position.y = coinData.startY + Math.sin((time + timeOffset) * hoverSpeed) * hoverHeight;
if (playerPosition.distanceTo(coin.position) < collectionDistance) { collectCoin(coinData); }
}
});
}
function collectCoin(coinData) {
if (coinData.collected) return;
coinData.collected = true;
scene.remove(coinData.mesh);
coinsCollected++;
const counter = document.getElementById('coin-counter');
counter.textContent = `COINS: ${coinsCollected} / ${TOTAL_COINS}`;
if (coinsCollected === TOTAL_COINS) {
counter.style.color = "#2a9d8f";
counter.textContent += " (ALL FOUND!)";
startFireworks();
}
}
function createFirework(x, y, z, color, life = 8.0) {
const particleCount = isMobileDevice() ? 80 : 150;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const velocities = new Float32Array(particleCount * 3);
const colorsArray = new Float32Array(particleCount * 3);
const baseColor = new THREE.Color(color);
for (let i = 0; i < particleCount; i++) {
const index = i * 3;
positions[index] = 0; positions[index + 1] = 0; positions[index + 2] = 0;
const speed = Math.random() * 30 + 15;
const phi = Math.random() * Math.PI * 2;
const theta = Math.random() * Math.PI;
velocities[index] = Math.sin(theta) * Math.cos(phi) * speed;
velocities[index + 1] = Math.cos(theta) * speed + 10;
velocities[index + 2] = Math.sin(theta) * Math.sin(phi) * speed;
const particleColor = baseColor.clone().multiplyScalar(Math.random() * 0.5 + 0.5);
colorsArray[index] = particleColor.r; colorsArray[index + 1] = particleColor.g; colorsArray[index + 2] = particleColor.b;
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
const material = new THREE.PointsMaterial({
size: isMobileDevice() ? 8 : 12, vertexColors: true, blending: THREE.AdditiveBlending,
transparent: true, depthWrite: false, sizeAttenuation: true
});
const particles = new THREE.Points(geometry, material);
particles.position.set(x, y, z);
fireworks.push({ particles: particles, life: life, maxLife: life });
scene.add(particles);
}
function startFireworks() {
const FIREWORK_DURATION = 20000; const FIREWORK_INTERVAL = 500;
const FIREWORK_Z_POSITION = -100; const FIREWORK_X_RANGE = 200; const FIREWORK_HEIGHT_RANGE = 60;
const fireworkColors = [0xe63946, 0x0077b6, 0x2a9d8f, 0xffd700, 0xff7d5c, 0x9d4edd];
let startTime = Date.now();
fireworkTimer = setInterval(() => {
if (Date.now() - startTime >= FIREWORK_DURATION) {
clearInterval(fireworkTimer); fireworkTimer = null; return;
}
const x = (Math.random() - 0.5) * FIREWORK_X_RANGE;
const y = Math.random() * FIREWORK_HEIGHT_RANGE + 80;
const z = FIREWORK_Z_POSITION + (Math.random() - 0.5) * 50;
const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
createFirework(x, y, z, color);
}, FIREWORK_INTERVAL);
}
function updateFireworks(delta) {
const particleGravity = -40;
for (let i = fireworks.length - 1; i >= 0; i--) {
const firework = fireworks[i];
firework.life -= delta;
if (firework.life <= 0) {
scene.remove(firework.particles);
firework.particles.geometry.dispose();
firework.particles.material.dispose();
fireworks.splice(i, 1);
continue;
}
const positions = firework.particles.geometry.attributes.position.array;
const velocities = firework.particles.geometry.attributes.velocity.array;
const particleCount = positions.length / 3;
for (let j = 0; j < particleCount; j++) {
const index = j * 3;
velocities[index + 1] += particleGravity * delta;
const drag = (1 - 0.8 * delta);
velocities[index] *= drag; velocities[index + 1] *= drag; velocities[index + 2] *= drag;
positions[index] += velocities[index] * delta;
positions[index + 1] += velocities[index + 1] * delta;
positions[index + 2] += velocities[index + 2] * delta;
}
firework.particles.material.opacity = firework.life / firework.maxLife;
firework.particles.geometry.attributes.position.needsUpdate = true;
}
}
function createSky() {
const uniforms = {
colorZenith: { value: new THREE.Color(colors.skyZenith) },
colorHorizonBright: { value: new THREE.Color(colors.horizonGlow) },
colorHorizonDark: { value: new THREE.Color(colors.skyHorizonDark) },
sunDirection: { value: sunDirectionVector }
};
const skyMaterial = new THREE.ShaderMaterial({
vertexShader: document.getElementById('sky-vertex-shader').textContent,
fragmentShader: document.getElementById('sky-fragment-shader').textContent,
uniforms: uniforms, side: THREE.BackSide, fog: false
});
const skyGeometry = new THREE.SphereGeometry(1750, 32, 16);
const sky = new THREE.Mesh(skyGeometry, skyMaterial);
scene.add(sky);
}
function setupLighting() {
const ambientLight = new THREE.AmbientLight(0x604080, 0.35);
scene.add(ambientLight);
const hemisphereLight = new THREE.HemisphereLight(colors.skyZenith, 0x8a5a6d, 0.5);
scene.add(hemisphereLight);
const sunLight = new THREE.DirectionalLight(0xffa500, 0.4);
sunLight.position.copy(sunDirectionVector.clone().multiplyScalar(300));
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 500;
sunLight.shadow.bias = -0.005;
const shadowSize = 180;
sunLight.shadow.camera.left = -shadowSize; sunLight.shadow.camera.right = shadowSize;
sunLight.shadow.camera.top = shadowSize; sunLight.shadow.camera.bottom = -shadowSize;
scene.add(sunLight);
}
function createTextTexture(text, bgColor, textColor, width=256, height=128, fontSize=50) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = width; canvas.height = height;
context.fillStyle = bgColor;
context.fillRect(0, 0, canvas.width, canvas.height);
context.font = `${fontSize}px 'VT323', Monospace`;
context.textAlign = 'center'; context.textBaseline = 'middle';
context.strokeStyle = 'black'; context.lineWidth = 4;
context.strokeText(text, canvas.width / 2, canvas.height / 2 + fontSize * 0.05);
context.fillStyle = textColor;
context.fillText(text, canvas.width / 2, canvas.height / 2 + fontSize * 0.05);
const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function createStripedTexture(color1, color2, stripeWidth=16) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = stripeWidth * 2; canvas.height = stripeWidth;
context.fillStyle = color1;
context.fillRect(0, 0, canvas.width, canvas.height);
context.fillStyle = color2;
context.fillRect(0, 0, stripeWidth, canvas.height);
const texture = new THREE.CanvasTexture(canvas);
texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function createTunnelSignTexture(text, width=512, height=64, fontSize=45) {
const canvas = document.createElement('canvas');
canvas.width = width; canvas.height = height;
const context = canvas.getContext('2d');
const stripeHeight = 16;
const numStripes = Math.ceil(height / stripeHeight);
for (let i = 0; i < numStripes; i++) {
context.fillStyle = (i % 2 === 0) ? '#000000' : '#f7b538';
context.fillRect(0, i * stripeHeight, width, stripeHeight);
}
context.font = `${fontSize}px 'VT323', Monospace`;
context.textAlign = 'center'; context.textBaseline = 'middle';
context.strokeStyle = 'black'; context.lineWidth = 8;
context.strokeText(text, canvas.width / 2, canvas.height / 2);
context.fillStyle = 'white';
context.fillText(text, canvas.width / 2, canvas.height / 2);
const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function createGrassTexture(width = 32, height = 32) {
const canvas = document.createElement('canvas');
canvas.width = width; canvas.height = height;
const context = canvas.getContext('2d');
const imageData = context.createImageData(width, height);
const data = imageData.data;
const baseColor = new THREE.Color(colors.grass);
for (let i = 0; i < data.length; i += 4) {
const noise = Math.random() * 0.15 - 0.075;
const c = baseColor.clone();
c.r += noise; c.g += noise; c.b += noise;
data[i] = Math.max(0, Math.min(255, c.r * 255));
data[i + 1] = Math.max(0, Math.min(255, c.g * 255));
data[i + 2] = Math.max(0, Math.min(255, c.b * 255));
data[i + 3] = 255;
}
context.putImageData(imageData, 0, 0);
const texture = new THREE.CanvasTexture(canvas);
texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(3000 / width, 3000 / height);
texture.minFilter = THREE.NearestFilter; texture.magFilter = THREE.NearestFilter;
return texture;
}
function createGround() {
const geometry = new THREE.PlaneGeometry(3000, 3000);
const grassTexture = createGrassTexture();
const material = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 1.0 });
const ground = new THREE.Mesh(geometry, material);
ground.rotation.x = -Math.PI / 2; ground.position.y = 0; ground.receiveShadow = true;
scene.add(ground);
const asphaltWidth = 500; const asphaltLength = 320;
const asphaltGeometry = new THREE.PlaneGeometry(asphaltWidth, asphaltLength);
const asphaltMaterial = new THREE.MeshStandardMaterial({ color: colors.asphalt, roughness: 1.0 });
const asphalt = new THREE.Mesh(asphaltGeometry, asphaltMaterial);
asphalt.rotation.x = -Math.PI / 2; asphalt.position.y = 0.01;
asphalt.position.z = asphaltLength / 2 - 60; asphalt.receiveShadow = true;
scene.add(asphalt);
const lineMaterial = new THREE.MeshBasicMaterial({ color: colors.asphaltLine });
const lineGeoSlanted = new THREE.PlaneGeometry(1.5, 20);
const lineGeoStraight = new THREE.PlaneGeometry(1.5, 25);
const createParkingRow = (startZ, count, startX, spacing, slant=false, offsetX=0) => {
const geo = slant ? lineGeoSlanted : lineGeoStraight;
const slantAngle = Math.PI / 5;
for (let i = 0; i < count; i++) {
const xPos = startX + i * spacing + offsetX;
const line = new THREE.Mesh(geo, lineMaterial);
line.rotation.x = -Math.PI / 2;
if (slant) { line.rotation.z = slantAngle; }
line.position.set(xPos, 0.02, startZ);
scene.add(line);
}
};
const numSpotsWide = 32; const startXWide = -240; const spacing = 15;
createParkingRow(35, 20, -140, spacing, true);
createParkingRow(55, 20, -140, spacing, true, -5);
createParkingRow(100, numSpotsWide, startXWide, spacing, false);
createParkingRow(130, numSpotsWide, startXWide, spacing, false);
createParkingRow(190, numSpotsWide, startXWide, spacing, false);
createParkingRow(220, numSpotsWide, startXWide, spacing, false);
createRoad();
}
function createRoad() {
const { width: roadWidth, length: roadLength, startZ: roadStartZ, shoulderWidth } = ROAD_CONFIG;
const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a15, roughness: 0.9, metalness: 0.1 });
const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
const road = new THREE.Mesh(roadGeometry, roadMaterial);
road.rotation.x = -Math.PI / 2; road.position.set(0, 0.11, roadStartZ + roadLength / 2);
road.receiveShadow = true; scene.add(road);
const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 });
const centerLineGeo = new THREE.PlaneGeometry(1.5, 18);
const dashSpacing = 25;
const numDashes = Math.floor(roadLength / dashSpacing);
for (let i = 0; i < numDashes; i++) {
const zPos = roadStartZ + (i * dashSpacing) + 10;
const centerLine = new THREE.Mesh(centerLineGeo, lineMaterial);
centerLine.rotation.x = -Math.PI / 2; centerLine.position.set(0, 0.12, zPos);
scene.add(centerLine);
}
const sideLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 });
const createSideLinesSegment = (start, end) => {
const segmentLength = end - start;
if (segmentLength <= 0) return;
const sideLineGeo = new THREE.PlaneGeometry(1.2, segmentLength);
const leftLine = new THREE.Mesh(sideLineGeo, sideLineMaterial);
leftLine.rotation.x = -Math.PI / 2; leftLine.position.set(-roadWidth/2 + 1, 0.12, start + segmentLength / 2);
scene.add(leftLine);
const rightLine = new THREE.Mesh(sideLineGeo, sideLineMaterial);
rightLine.rotation.x = -Math.PI / 2; rightLine.position.set(roadWidth/2 - 1, 0.12, start + segmentLength / 2);
scene.add(rightLine);
};
createSideLinesSegment(roadStartZ, ROAD_CONFIG.endZ);
const shoulderMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2035, roughness: 1.0 });
const createShoulderSegment = (start, end) => {
const segmentLength = end - start;
if (segmentLength <= 0) return;
const shoulderGeo = new THREE.PlaneGeometry(shoulderWidth, segmentLength);
const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMaterial);
leftShoulder.rotation.x = -Math.PI / 2; leftShoulder.position.set(-roadWidth/2 - shoulderWidth/2, 0.14, start + segmentLength / 2);
leftShoulder.receiveShadow = true; scene.add(leftShoulder);
const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMaterial);
rightShoulder.rotation.x = -Math.PI / 2; rightShoulder.position.set(roadWidth/2 + shoulderWidth/2, 0.14, start + segmentLength / 2);
rightShoulder.receiveShadow = true; scene.add(rightShoulder);
};
createShoulderSegment(roadStartZ, TUNNEL_CONFIG.startZ);
createShoulderSegment(TUNNEL_CONFIG.endZ, ROAD_CONFIG.endZ);
const roadLightSpacing = 100;
for (let z = roadStartZ + 50; z < TUNNEL_CONFIG.startZ - 50; z += roadLightSpacing) {
const roadLight = new THREE.PointLight(0xffd4a3, 0.8, 80);
roadLight.position.set(-roadWidth/2 - 15, 35, z); scene.add(roadLight);
const roadLight2 = new THREE.PointLight(0xffd4a3, 0.8, 80);
roadLight2.position.set(roadWidth/2 + 15, 35, z); scene.add(roadLight2);
}
}
function createTunnel() {
const { startZ: tunnelStartZ, length: tunnelLength, width: tunnelWidth, height: tunnelHeight, wallThickness } = TUNNEL_CONFIG;
const wallTextureCanvas = document.createElement('canvas');
wallTextureCanvas.width = 32; wallTextureCanvas.height = 128;
const wallCtx = wallTextureCanvas.getContext('2d');
wallCtx.fillStyle = '#3a3a4a'; wallCtx.fillRect(0, 0, wallTextureCanvas.width, wallTextureCanvas.height);
wallCtx.fillStyle = '#2f2f3f'; wallCtx.fillRect(0, 62, 32, 4);
const wallTexture = new THREE.CanvasTexture(wallTextureCanvas);
wallTexture.wrapS = THREE.RepeatWrapping; wallTexture.wrapT = THREE.RepeatWrapping;
wallTexture.repeat.set(tunnelLength / 10, 4);
const tunnelMaterial = new THREE.MeshStandardMaterial({ color: colors.tunnelConcrete, roughness: 0.9, side: THREE.DoubleSide, map: wallTexture });
const shape = new THREE.Shape();
const outerWidth = tunnelWidth + wallThickness * 2;
const outerHeight = tunnelHeight + wallThickness;
shape.moveTo(-outerWidth * 1.5, 0); shape.lineTo(-outerWidth / 2, 0);
shape.lineTo(-outerWidth / 2, outerHeight * 0.6);
shape.quadraticCurveTo(0, outerHeight + 15, outerWidth / 2, outerHeight * 0.6);
shape.lineTo(outerWidth / 2, 0); shape.lineTo(outerWidth * 1.5, 0); shape.closePath();
const hole = new THREE.Shape();
const sideWallHeight = tunnelHeight * 0.6;
hole.moveTo(-tunnelWidth / 2, 0.1); hole.lineTo(-tunnelWidth / 2, sideWallHeight);
hole.quadraticCurveTo(0, tunnelHeight + 5, tunnelWidth / 2, sideWallHeight);
hole.lineTo(tunnelWidth / 2, 0.1); hole.closePath();
shape.holes.push(hole);
const extrudeSettings = { steps: 1, depth: tunnelLength, bevelEnabled: false };
const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
const tunnel = new THREE.Mesh(geometry, tunnelMaterial);
tunnel.position.set(0, 0.01, tunnelStartZ);
tunnel.castShadow = true; tunnel.receiveShadow = true;
scene.add(tunnel);
const facadeMaterial = new THREE.MeshStandardMaterial({ color: colors.tunnelFacade, roughness: 1.0 });
const facadeShape = new THREE.Shape();
const facadeWidth = outerWidth + 6;
const facadeOuterSideWallHeight = outerHeight * 0.6 + 3;
facadeShape.moveTo(-facadeWidth / 2, 0); facadeShape.lineTo(-facadeWidth / 2, facadeOuterSideWallHeight);
facadeShape.quadraticCurveTo(0, outerHeight + 20, facadeWidth / 2, facadeOuterSideWallHeight);
facadeShape.lineTo(facadeWidth / 2, 0); facadeShape.closePath();
facadeShape.holes.push(hole);
const facadeGeometry = new THREE.ExtrudeGeometry(facadeShape, { steps: 1, depth: 5, bevelEnabled: false });
const entranceFacade = new THREE.Mesh(facadeGeometry, facadeMaterial);
entranceFacade.position.set(0, 0.01, tunnelStartZ - 5); entranceFacade.castShadow = true;
scene.add(entranceFacade);
const exitFacade = new THREE.Mesh(facadeGeometry, facadeMaterial);
exitFacade.position.set(0, 0.01, tunnelStartZ + tunnelLength); exitFacade.castShadow = true;
scene.add(exitFacade);
const detailMaterial = new THREE.MeshStandardMaterial({ color: colors.tunnelFacade, roughness: 1.0 });
detailMaterial.color.multiplyScalar(0.7);
const pillarHeight = facadeOuterSideWallHeight + 1; const pillarWidth = 4; const pillarDepth = 6;
const pillarGeo = new THREE.BoxGeometry(pillarWidth, pillarHeight, pillarDepth);
const leftPillar = new THREE.Mesh(pillarGeo, detailMaterial);
leftPillar.position.set(-facadeWidth / 2 - pillarWidth / 2, pillarHeight / 2 + 0.01, tunnelStartZ - pillarDepth / 2 + 2.5);
leftPillar.castShadow = true; scene.add(leftPillar);
const rightPillar = new THREE.Mesh(pillarGeo, detailMaterial);
rightPillar.position.set(facadeWidth / 2 + pillarWidth / 2, pillarHeight / 2 + 0.01, tunnelStartZ - pillarDepth / 2 + 2.5);
rightPillar.castShadow = true; scene.add(rightPillar);
const leftPillarExit = new THREE.Mesh(pillarGeo, detailMaterial);
leftPillarExit.position.set(-facadeWidth / 2 - pillarWidth / 2, pillarHeight / 2 + 0.01, tunnelStartZ + tunnelLength + pillarDepth / 2 - 2.5);
leftPillarExit.castShadow = true; scene.add(leftPillarExit);
const rightPillarExit = new THREE.Mesh(pillarGeo, detailMaterial);
rightPillarExit.position.set(facadeWidth / 2 + pillarWidth / 2, pillarHeight / 2 + 0.01, tunnelStartZ + tunnelLength + pillarDepth / 2 - 2.5);
rightPillarExit.castShadow = true; scene.add(rightPillarExit);
const signHeight = 5; const signWidth = tunnelWidth - 10;
const warningTexture = createTunnelSignTexture("TUNNEL", 512, 128, 150);
const warningSignGeo = new THREE.BoxGeometry(signWidth, signHeight, 0.5);
const warningSignMat = new THREE.MeshBasicMaterial({ map: warningTexture });
const warningSign = new THREE.Mesh(warningSignGeo, warningSignMat);
const archTopY = tunnelHeight + 5;
warningSign.position.set(0, archTopY + signHeight / 2 + 1 + 0.01, tunnelStartZ - 4.8);
scene.add(warningSign);
const blackoutHole = new THREE.Shape();
blackoutHole.moveTo(-tunnelWidth / 2, 0.5); blackoutHole.lineTo(-tunnelWidth / 2, sideWallHeight);
blackoutHole.quadraticCurveTo(0, tunnelHeight + 5, tunnelWidth / 2, sideWallHeight);
blackoutHole.lineTo(tunnelWidth / 2, 0.5); blackoutHole.closePath();
const blackoutGeo = new THREE.ShapeGeometry(blackoutHole);
const blackoutMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, fog: false });
const blackoutPlane = new THREE.Mesh(blackoutGeo, blackoutMaterial);
blackoutPlane.position.set(0, 0, tunnelStartZ + tunnelLength - 10);
scene.add(blackoutPlane);
const lightIntensity = 1.2; const lightSpacing = 50; const lightHeight = 22;
const lightXOffset = tunnelWidth / 2 * 0.9;
const fixtureHousingMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
const fixtureLightMat = new THREE.MeshBasicMaterial({ color: colors.tunnelLight });
const housingGeo = new THREE.BoxGeometry(1.5, 1.5, 6);
const lightGeo = new THREE.BoxGeometry(1.0, 1.0, 5);
for (let z = tunnelStartZ + 30; z < tunnelStartZ + tunnelLength - 30; z += lightSpacing) {
const leftLight = new THREE.PointLight(colors.tunnelLight, lightIntensity, 60);
leftLight.position.set(-lightXOffset, lightHeight, z); scene.add(leftLight);
const leftFixture = new THREE.Group();
const leftHousing = new THREE.Mesh(housingGeo, fixtureHousingMat);
const leftLightBox = new THREE.Mesh(lightGeo, fixtureLightMat);
leftLightBox.position.y = -0.25;
leftFixture.add(leftHousing, leftLightBox);
leftFixture.position.set(-lightXOffset, lightHeight, z); scene.add(leftFixture);
const rightLight = new THREE.PointLight(colors.tunnelLight, lightIntensity, 60);
rightLight.position.set(lightXOffset, lightHeight, z); scene.add(rightLight);
const rightFixture = new THREE.Group();
const rightHousing = new THREE.Mesh(housingGeo, fixtureHousingMat);
const rightLightBox = new THREE.Mesh(lightGeo, fixtureLightMat);
rightLightBox.position.y = -0.25;
rightFixture.add(rightHousing, rightLightBox);
rightFixture.position.set(lightXOffset, lightHeight, z); scene.add(rightFixture);
}
createBush(-85, tunnelStartZ - 20); createBush(-70, tunnelStartZ - 45);
createBush(-95, tunnelStartZ - 55); createBush(-105, tunnelStartZ - 30);
createBush(85, tunnelStartZ - 20); createBush(75, tunnelStartZ - 35);
createBush(90, tunnelStartZ - 50); createBush(105, tunnelStartZ - 30);
}
function createParkingLights() {
const poleMat = new THREE.MeshStandardMaterial({ color: colors.poleMetal });
const lightMat = new THREE.MeshBasicMaterial({ color: colors.poleGlow });
const poleHeight = 40;
const createParkingLight = (x, z) => {
const poleGeo = new THREE.CylinderGeometry(0.8, 1.2, poleHeight, 6);
poleGeo.translate(0, poleHeight / 2, 0);
const pole = new THREE.Mesh(poleGeo, poleMat);
pole.position.set(x, 0, z); pole.castShadow = true; scene.add(pole);
const fixtureGeo = new THREE.BoxGeometry(8, 2, 6);
const fixture = new THREE.Mesh(fixtureGeo, poleMat);
fixture.position.set(x, poleHeight + 1, z); fixture.castShadow = true; scene.add(fixture);
const bulbGeo = new THREE.BoxGeometry(6, 0.5, 4);
const bulb = new THREE.Mesh(bulbGeo, lightMat);
bulb.position.set(x, poleHeight, z); scene.add(bulb);
const light = new THREE.SpotLight(colors.poleGlow, 2.0, 120, Math.PI/3, 0.5);
light.position.set(x, poleHeight - 1, z);
light.target.position.set(x, 0, z);
light.castShadow = true;
scene.add(light); scene.add(light.target);
};
createParkingLight(-150, 75); createParkingLight(0, 75); createParkingLight(150, 75);
createParkingLight(-150, 160); createParkingLight(0, 160); createParkingLight(150, 160);
createParkingLight(-80, 250); createParkingLight(80, 250);
}
function addControllerElements(centerX, y, z) {
const dPadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
const dPadThickness = 0.5; const dPadSize = 4; const dPadArmWidth = 1.5;
const hGeo = new THREE.BoxGeometry(dPadSize, dPadArmWidth, dPadThickness);
const hPart = new THREE.Mesh(hGeo, dPadMaterial); hPart.castShadow = true;
const vGeo = new THREE.BoxGeometry(dPadArmWidth, dPadSize, dPadThickness);
const vPart = new THREE.Mesh(vGeo, dPadMaterial); vPart.castShadow = true;
const dPadGroup = new THREE.Group();
dPadGroup.add(hPart); dPadGroup.add(vPart);
dPadGroup.position.set(centerX - 7, 8, z);
scene.add(dPadGroup);
const buttonGroup = new THREE.Group();
const buttonRadius = 1.0; const buttonThickness = 0.4; const buttonSpacing = 2.5;
const createButton = (x, y, color, label, textureRotation = 0) => {
const geometry = new THREE.CylinderGeometry(buttonRadius, buttonRadius, buttonThickness, 16);
geometry.rotateX(Math.PI / 2);
const faceTexture = createTextTextureSync(label, '#ffffff', 30);
faceTexture.rotation = textureRotation; faceTexture.center.set(0.5, 0.5);
const faceMaterial = new THREE.MeshStandardMaterial({ color: color, map: faceTexture, roughness: 0.3 });
const sideMaterial = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
const button = new THREE.Mesh(geometry, [sideMaterial, faceMaterial, sideMaterial]);
button.position.set(x, y, 0); button.castShadow = true;
buttonGroup.add(button);
};
createButton(0, -buttonSpacing, 0x2ecc71, 'A', Math.PI / 2);
createButton(-buttonSpacing, 0, 0xe74c3c, 'B', Math.PI / 2);
createButton(0, buttonSpacing, 0xf1c40f, 'Y', Math.PI / 2);
createButton(buttonSpacing, 0, 0x3498db, 'X', Math.PI / 2);
buttonGroup.position.set(centerX + 7, 8, z);
scene.add(buttonGroup);
}
function createBuilding() {
const buildingHeight = 25; const buildingDepth = 30; const zPos = 0;
const centerMaterial = new THREE.MeshStandardMaterial({ color: colors.stucco });
const trimMaterial = new THREE.MeshStandardMaterial({ color: colors.stuccoDark });
const sideMaterial = new THREE.MeshStandardMaterial({ color: colors.brick });
const centerWidth = 35; const centerHeight = buildingHeight + 3;
const centerGeo = new THREE.BoxGeometry(centerWidth, centerHeight, buildingDepth);
centerGeo.translate(0, centerHeight / 2, 0);
const centerBlock = new THREE.Mesh(centerGeo, centerMaterial);
centerBlock.position.set(0, 0, zPos); centerBlock.castShadow = true; centerBlock.receiveShadow = true;
scene.add(centerBlock);
const roofTrimCGeo = new THREE.BoxGeometry(centerWidth + 4, 4, buildingDepth + 2);
const roofTrimC = new THREE.Mesh(roofTrimCGeo, trimMaterial);
roofTrimC.position.set(0, buildingHeight + 3, zPos); roofTrimC.castShadow = true;
scene.add(roofTrimC);
const archGeo = new THREE.BoxGeometry(centerWidth - 10, 6, buildingDepth + 1);
const arch = new THREE.Mesh(archGeo, centerMaterial);
arch.position.set(0, buildingHeight + 7, zPos); arch.castShadow = true;
scene.add(arch);
const sideWidth = 32;
const sideGeo = new THREE.BoxGeometry(sideWidth, buildingHeight, buildingDepth);
sideGeo.translate(0, buildingHeight / 2, 0);
const xPosLeft = -(centerWidth/2 + sideWidth/2);
const xPosRight = centerWidth/2 + sideWidth/2;
const xPosFarRight = xPosRight + sideWidth;
const xPosExtraFarRight = xPosFarRight + sideWidth;
const leftBlock = new THREE.Mesh(sideGeo, sideMaterial);
leftBlock.position.set(xPosLeft, 0, zPos); leftBlock.castShadow = true; leftBlock.receiveShadow = true;
scene.add(leftBlock);
const rightBlock = new THREE.Mesh(sideGeo, sideMaterial);
rightBlock.position.set(xPosRight, 0, zPos); rightBlock.castShadow = true; rightBlock.receiveShadow = true;
scene.add(rightBlock);
const farRightBlock = new THREE.Mesh(sideGeo, sideMaterial);
farRightBlock.position.set(xPosFarRight, 0, zPos); farRightBlock.castShadow = true; farRightBlock.receiveShadow = true;
scene.add(farRightBlock);
const extraFarRightBlock = new THREE.Mesh(sideGeo, sideMaterial);
extraFarRightBlock.position.set(xPosExtraFarRight, 0, zPos); extraFarRightBlock.castShadow = true; extraFarRightBlock.receiveShadow = true;
scene.add(extraFarRightBlock);
const roofTrimSGeo = new THREE.BoxGeometry(sideWidth + 2, 3, buildingDepth + 2);
const roofTrimL = new THREE.Mesh(roofTrimSGeo, trimMaterial);
roofTrimL.position.set(xPosLeft, buildingHeight + 0.5, zPos); roofTrimL.castShadow = true;
scene.add(roofTrimL);
const roofTrimR = new THREE.Mesh(roofTrimSGeo, trimMaterial);
roofTrimR.position.set(xPosRight, buildingHeight + 0.5, zPos); roofTrimR.castShadow = true;
scene.add(roofTrimR);
const roofTrimFR = new THREE.Mesh(roofTrimSGeo, trimMaterial);
roofTrimFR.position.set(xPosFarRight, buildingHeight + 0.5, zPos); roofTrimFR.castShadow = true;
scene.add(roofTrimFR);
const roofTrimEFR = new THREE.Mesh(roofTrimSGeo, trimMaterial);
roofTrimEFR.position.set(xPosExtraFarRight, buildingHeight + 0.5, zPos); roofTrimEFR.castShadow = true;
scene.add(roofTrimEFR);
const windowZ = zPos + buildingDepth / 2 + 0.1; const windowY = 8;
const itemZ = 19; const itemZ2 = 20.5;
createWindow(0, windowY, windowZ, 28, 12, colors.windowGlowBright, 1.5);
addShirt(-10, 8, itemZ, 0x457b9d); addShirt(10, 8, itemZ, 0xe63946); addShirt(0, 7.5, itemZ2, 0x1d3557);
createWindow(xPosLeft, windowY, windowZ, 26, 12, colors.windowGlowBright, 1.2);
addPaper(xPosLeft - 7, 8, itemZ); addPaper(xPosLeft + 7, 8.5, itemZ); addPaper(xPosLeft, 7, itemZ);
createWindow(xPosRight, windowY, windowZ, 26, 12, colors.windowGlowDim, 0.8);
addPaper(xPosRight - 7, 8.5, itemZ); addPaper(xPosRight + 7, 8, itemZ); addPaper(xPosRight + 1, 7.5, itemZ);
createWindow(xPosFarRight, windowY, windowZ, 26, 12, colors.windowGlowBright, 1.2);
addThoughtBubble(xPosFarRight + 5, 8.5, itemZ, 8, 5.5, 0xffe066, 'bottom-right');
addThoughtBubble(xPosFarRight - 6, 7.5, itemZ2, 6, 4, 0x48bfe3, 'bottom-left');
addThoughtBubble(xPosFarRight - 1, 11.5, itemZ, 4.5, 3, 0xfb6f92, 'top-left');
createWindow(xPosExtraFarRight, windowY, windowZ, 26, 12, colors.windowGlowDim, 1.0);
addControllerElements(xPosExtraFarRight, windowY, itemZ);
const signZ = windowZ + 0.5;
createSign("RESUME", colors.signResume, xPosLeft, 20, signZ, 'resume', 50);
createSign("T-SHIRTS", colors.signTshirts, 0, 21, signZ, 'tshirts', 50);
createSign("PROJECTS", colors.signProjects, xPosRight, 20, signZ, 'projects', 50);
createSign("ASK JOHN", colors.signAskJohn, xPosFarRight, 20, signZ, 'askjohn', 50);
createSign("MINI GAMES", colors.signMiniGames, xPosExtraFarRight, 20, signZ, 'minigames', 45);
const awningY = 15;
const texResume = createStripedTexture('#991b1b', '#fecaca');
createAwning(xPosLeft, awningY, texResume);
const texProjects = createStripedTexture('#065f46', '#047857');
createAwning(xPosRight, awningY, texProjects);
const texAskJohn = createStripedTexture('#ffA700', '#333333');
createAwning(xPosFarRight, awningY, texAskJohn);
const texMiniGames = createStripedTexture('#6a0dad', '#4b0082');
createAwning(xPosExtraFarRight, awningY, texMiniGames);
}
function createWindow(x, y, z, width, height, color, intensity) {
const windowMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.95 });
const windowGeo = new THREE.PlaneGeometry(width, height);
const windowMesh = new THREE.Mesh(windowGeo, windowMaterial);
windowMesh.position.set(x, y, z);
scene.add(windowMesh);
const storeLight = new THREE.PointLight(color, intensity, 50);
storeLight.position.set(x, y + 5, z - 15); storeLight.castShadow = true;
scene.add(storeLight);
const sidewalkLight = new THREE.SpotLight(color, intensity * 0.3, 40, Math.PI/3, 0.5);
sidewalkLight.position.set(x, y-5, z+5);
sidewalkLight.target.position.set(x, 0, z+25);
scene.add(sidewalkLight); scene.add(sidewalkLight.target);
}
function addShirt(x, y, z, color) {
const material = new THREE.MeshStandardMaterial({
color: color, depthWrite: true, depthTest: true, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1
});
const shirtGroup = new THREE.Group();
const bodyGeo = new THREE.BoxGeometry(5, 6, 2); bodyGeo.rotateY(Math.PI);
const body = new THREE.Mesh(bodyGeo, material);
body.position.z = 0.3; body.renderOrder = 1; shirtGroup.add(body);
const sleeveGeo = new THREE.BoxGeometry(2.5, 2.5, 1.8); sleeveGeo.rotateY(Math.PI);
const sleeveL = new THREE.Mesh(sleeveGeo, material);
sleeveL.position.set(-3.5, 1.5, 0.2); sleeveL.rotation.z = Math.PI / 6;
sleeveL.renderOrder = 1; shirtGroup.add(sleeveL);
const sleeveR = new THREE.Mesh(sleeveGeo, material);
sleeveR.position.set(3.5, 1.5, 0.2); sleeveR.rotation.z = -Math.PI / 6;
sleeveR.renderOrder = 1; shirtGroup.add(sleeveR);
shirtGroup.position.set(x, y, z); shirtGroup.castShadow = true;
scene.add(shirtGroup);
}
function addPaper(x, y, z) {
const material = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.8 });
const paperGeo = new THREE.BoxGeometry(4, 5.5, 0.2); paperGeo.rotateY(Math.PI);
const paper = new THREE.Mesh(paperGeo, material);
paper.position.set(x, y, z);
paper.rotation.z = (Math.random() - 0.5) * 0.3;
paper.rotation.x = Math.PI / 12 + (Math.random() - 0.5) * 0.2;
paper.castShadow = true;
scene.add(paper);
}
function addThoughtBubble(x, y, z, width, height, color, pointerSide = 'bottom-left') {
const material = new THREE.MeshStandardMaterial({
color: color, roughness: 0.6, side: THREE.DoubleSide, depthWrite: true, depthTest: true,
polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1
});
const shape = new THREE.Shape();
const radiusX = width / 2; const radiusY = height / 2;
shape.absellipse(0, 0, radiusX, radiusY, 0, Math.PI * 2, false, 0);
const extrudeSettings = {
steps: 1, depth: 0.5, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3
};
const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
geometry.rotateY(Math.PI);
const bubble = new THREE.Mesh(geometry, material); bubble.renderOrder = 1;
const pointerShape = new THREE.Shape();
const pointerSize = Math.min(width, height) * 0.3;
let p1x, p1y, p2x, p2y, p3x, p3y;
switch (pointerSide) {
case 'top-left':
p1x = -radiusX * 0.3; p1y = radiusY * 0.95; p2x = p1x - pointerSize * 0.5; p2y = p1y + pointerSize; p3x = p1x + pointerSize * 0.3; p3y = radiusY * 0.95;
break;
case 'top-right':
p1x = radiusX * 0.3; p1y = radiusY * 0.95; p2x = p1x + pointerSize * 0.5; p2y = p1y + pointerSize; p3x = p1x - pointerSize * 0.3; p3y = radiusY * 0.95;
break;
case 'bottom-right':
p1x = radiusX * 0.4; p1y = -radiusY * 0.95; p2x = p1x + pointerSize * 0.6; p2y = p1y - pointerSize; p3x = p1x - pointerSize * 0.2; p3y = -radiusY * 0.95;
break;
case 'bottom-left':
default:
p1x = -radiusX * 0.4; p1y = -radiusY * 0.95; p2x = p1x - pointerSize * 0.6; p2y = p1y - pointerSize; p3x = p1x + pointerSize * 0.2; p3y = -radiusY * 0.95;
break;
}
pointerShape.moveTo(p1x, p1y); pointerShape.lineTo(p2x, p2y); pointerShape.lineTo(p3x, p3y); pointerShape.closePath();
const pointerGeometry = new THREE.ExtrudeGeometry(pointerShape, extrudeSettings);
pointerGeometry.rotateY(Math.PI);
const pointerMesh = new THREE.Mesh(pointerGeometry, material); pointerMesh.renderOrder = 1;
const group = new THREE.Group();
group.add(bubble); group.add(pointerMesh);
group.position.set(x, y, z + extrudeSettings.depth/2); group.castShadow = true;
scene.add(group);
}
function createAwning(xPos, yPos, texture) {
texture.repeat.set(6, 1);
const material = new THREE.MeshStandardMaterial({ map: texture });
const geometry = new THREE.BoxGeometry(32, 1.5, 8);
const awning = new THREE.Mesh(geometry, material);
awning.position.set(xPos, yPos, 15 + 3);
awning.rotation.x = Math.PI / 4; awning.castShadow = true;
scene.add(awning);
}
function createSign(text, color, xPos, yPos, zPos, id, fontSize = 45) {
const texture = createTextTexture(text, new THREE.Color(color).getStyle(), '#ffffff', 256, 64, fontSize);
const material = new THREE.MeshBasicMaterial({ map: texture });
const geometry = new THREE.BoxGeometry(26, 5, 1.5);
const sign = new THREE.Mesh(geometry, material);
sign.position.set(xPos, yPos, zPos);
sign.name = id;
scene.add(sign);
clickableObjects.push(sign);
}
function createBillboard() {
const poleHeight = 70; const totalPoleHeight = poleHeight + 30;
const boardY = poleHeight + 15; const boardZ = -30;
const rotationAngle = 35 * Math.PI / 180;
const billboardGroup = new THREE.Group();
billboardGroup.position.set(0, 0, boardZ); billboardGroup.rotation.y = rotationAngle;
const poleGeo = new THREE.CylinderGeometry(2.5, 2.5, totalPoleHeight, 8);
poleGeo.translate(0, totalPoleHeight / 2, 0);
const poleMat = new THREE.MeshStandardMaterial({ color: colors.metalDark });
const pole = new THREE.Mesh(poleGeo, poleMat);
pole.position.set(0, 0, 0); pole.castShadow = true;
billboardGroup.add(pole);
const boardWidth = 80; const boardHeight = 35;
const texture = createTextTexture("JOHN GRESH", new THREE.Color(colors.billboardGlow).getStyle(), new THREE.Color(colors.billboardText).getStyle(), 512, 256, 70);
texture.generateMipmaps = false;
const boardMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });
const boardGeo = new THREE.BoxGeometry(boardWidth, boardHeight, 0.5);
const board = new THREE.Mesh(boardGeo, boardMat);
board.position.set(0, boardY, 3); board.renderOrder = 1;
billboardGroup.add(board);
const structureMat = new THREE.MeshStandardMaterial({ color: colors.metalDark });
const structureGeo = new THREE.BoxGeometry(boardWidth + 6, boardHeight + 6, 1);
const structure = new THREE.Mesh(structureGeo, structureMat);
structure.position.set(0, boardY, 0); structure.castShadow = true; structure.renderOrder = 0;
billboardGroup.add(structure);
const ledgeWidth = boardWidth + 6; const ledgeDepth = 4; const ledgeHeight = 1;
const ledgeGeo = new THREE.BoxGeometry(ledgeWidth, ledgeHeight, ledgeDepth);
const ledgeBack = new THREE.Mesh(ledgeGeo, structureMat);
const structureBottomY = boardY - (boardHeight + 6) / 2;
ledgeBack.position.set(0, structureBottomY - ledgeHeight / 2, -0.5 - ledgeDepth / 2);
ledgeBack.castShadow = true; billboardGroup.add(ledgeBack);
const railingHeight = 4; const railThickness = 0.4;
const topRailGeo = new THREE.BoxGeometry(ledgeWidth, railThickness, railThickness);
const topRailBack = new THREE.Mesh(topRailGeo, structureMat);
const ledgeTopY = structureBottomY;
const ledgeBackZ = -0.5 - ledgeDepth;
topRailBack.position.set(0, ledgeTopY + railingHeight - railThickness / 2, ledgeBackZ + railThickness / 2);
topRailBack.castShadow = true; billboardGroup.add(topRailBack);
const postGeo = new THREE.BoxGeometry(railThickness, railingHeight, railThickness);
const numPosts = 7;
for (let i = 0; i < numPosts; i++) {
const post = new THREE.Mesh(postGeo, structureMat);
const xPos = -ledgeWidth / 2 + railThickness / 2 + i * ((ledgeWidth-railThickness) / (numPosts - 1));
post.position.set(xPos, ledgeTopY + railingHeight / 2, ledgeBackZ + railThickness / 2);
post.castShadow = true; billboardGroup.add(post);
}
const ledgeFront = new THREE.Mesh(ledgeGeo, structureMat);
ledgeFront.position.set(0, structureBottomY - ledgeHeight / 2, 0.5 + ledgeDepth / 2 + 2.5);
ledgeFront.castShadow = true; billboardGroup.add(ledgeFront);
const topRailFront = new THREE.Mesh(topRailGeo, structureMat);
const ledgeFrontZ = 0.5 + ledgeDepth + 2.5;
topRailFront.position.set(0, ledgeTopY + railingHeight - railThickness / 2, ledgeFrontZ - railThickness / 2);
topRailFront.castShadow = true; billboardGroup.add(topRailFront);
for (let i = 0; i < numPosts; i++) {
const post = new THREE.Mesh(postGeo, structureMat);
const xPos = -ledgeWidth / 2 + railThickness / 2 + i * ((ledgeWidth-railThickness) / (numPosts - 1));
post.position.set(xPos, ledgeTopY + railingHeight / 2, ledgeFrontZ - railThickness / 2);
post.castShadow = true; billboardGroup.add(post);
}
const lightFixtureMat = new THREE.MeshBasicMaterial({color: 0x333333});
const lightBulbMat = new THREE.MeshBasicMaterial({color: colors.billboardGlow});
for(let i = -1.5; i <= 1.5; i++){
const fixtureX = i * 25; const fixtureY = boardY + boardHeight/2 + 3;
const fixtureGroup = new THREE.Group();
fixtureGroup.position.set(fixtureX, fixtureY, 5);
const headGeo = new THREE.BoxGeometry(5, 2, 2);
const head = new THREE.Mesh(headGeo, lightFixtureMat);
head.position.set(0, 0, 0); fixtureGroup.add(head);
const bulbGeo = new THREE.BoxGeometry(4, 0.8, 0.8);
const bulb = new THREE.Mesh(bulbGeo, lightBulbMat);
bulb.position.set(0, -0.8, 0.5); fixtureGroup.add(bulb);
const armGeo = new THREE.BoxGeometry(1, 4, 1);
const arm = new THREE.Mesh(armGeo, lightFixtureMat);
arm.position.set(0, -2, -3); fixtureGroup.add(arm);
billboardGroup.add(fixtureGroup);
const spotlight = new THREE.SpotLight(0xfff8e1, 2.5, 120, Math.PI/8, 0.5);
spotlight.position.set(fixtureX, fixtureY, 5);
spotlight.target = board;
billboardGroup.add(spotlight);
}
scene.add(billboardGroup);
}
function createBush(x, z, scale = 1.0) {
const foliageMaterial = new THREE.MeshStandardMaterial({ color: colors.treeDark, roughness: 1.0 });
foliageMaterial.color.multiplyScalar(0.85);
const bushGroup = new THREE.Group();
const numLumps = Math.floor(Math.random() * 3) + 4;
for (let i = 0; i < numLumps; i++) {
const lumpSize = (Math.random() * 5 + 5) * scale;
const lumpGeo = new THREE.BoxGeometry(lumpSize, lumpSize, lumpSize);
const lump = new THREE.Mesh(lumpGeo, foliageMaterial);
const offsetX = (Math.random() - 0.5) * 6 * scale;
const offsetY = lumpSize / 2 - 2 * scale;
const offsetZ = (Math.random() - 0.5) * 6 * scale;
lump.position.set(offsetX, offsetY, offsetZ);
lump.rotation.y = Math.random() * Math.PI;
lump.castShadow = true;
bushGroup.add(lump);
}
bushGroup.position.set(x, 0, z);
scene.add(bushGroup);
}
function createTrees() {
const trunkMaterial = new THREE.MeshStandardMaterial({ color: colors.treeTrunk, roughness: 1.0 });
const foliageMaterial = new THREE.MeshStandardMaterial({ color: colors.treeDark, roughness: 1.0 });
const distantFoliageMaterial = new THREE.MeshStandardMaterial({ color: colors.treeDark, roughness: 1.0, fog: true });
distantFoliageMaterial.color.multiplyScalar(0.5);
const { width: roadWidth, length: roadLength, startZ: roadStartZ, endZ: roadEndZ } = ROAD_CONFIG;
const roadClearance = 25;
const { startZ: tunnelStartZ, endZ: tunnelEndZ, clearanceWidth: tunnelClearanceWidth } = TUNNEL_CONFIG;
const isInRoadClearance = (x, z) => {
if (z >= roadStartZ && z <= roadEndZ) { return Math.abs(x) < (roadWidth/2 + roadClearance); }
return false;
};
const isOnParkingLot = (x, z) => {
const asphaltWidth = 500; const asphaltLength = 320;
const asphaltCenterZ = asphaltLength / 2 - 60;
if (Math.abs(x) < asphaltWidth / 2 && z > (asphaltCenterZ - asphaltLength / 2) && z < (asphaltCenterZ + asphaltLength / 2)) { return true; }
return false;
};
const isInTunnelClearance = (x, z) => {
const entranceZ = tunnelStartZ - 50; const exitZ = tunnelEndZ + 50;
if (z >= entranceZ && z <= exitZ) { return Math.abs(x) < tunnelClearanceWidth / 2; }
return false;
};
const createTree = (x, z, scale = 1.0, isDistant = false, y = 0) => {
if (y === 0) {
if (isInTunnelClearance(x, z) || isOnParkingLot(x, z) || (!isDistant && isInRoadClearance(x, z))) { return; }
}
const trunkHeight = (Math.random() * 10 + 15) * scale;
const trunkRadius = (Math.random() * 1.5 + 1.5) * scale;
const currentFoliageMaterial = isDistant ? distantFoliageMaterial : foliageMaterial;
if (!isDistant) {
const trunkGeo = new THREE.CylinderGeometry(trunkRadius*0.8, trunkRadius, trunkHeight, 6);
trunkGeo.translate(0, trunkHeight / 2, 0);
const trunk = new THREE.Mesh(trunkGeo, trunkMaterial);
trunk.position.set(x, y, z); trunk.castShadow = true;
scene.add(trunk);
}
const foliageLevels = 3;
let currentY = y + (isDistant ? 0 : trunkHeight * 0.8);
let baseWidth = (Math.random() * 20 + 25) * scale;
for (let i = 0; i < foliageLevels; i++) {
const levelHeight = (Math.random() * 15 + 12) * scale;
const levelWidth = baseWidth * (1 - i * 0.25);
const foliageGeo = new THREE.BoxGeometry(levelWidth, levelHeight, levelWidth);
const foliage = new THREE.Mesh(foliageGeo, currentFoliageMaterial);
const offsetX = (Math.random() - 0.5) * 6 * scale;
const offsetZ = (Math.random() - 0.5) * 6 * scale;
foliage.position.set(x + offsetX, currentY + levelHeight / 2, z + offsetZ);
foliage.rotation.y = Math.random() * Math.PI;
if (!isDistant) { foliage.castShadow = true; foliage.receiveShadow = true; }
scene.add(foliage);
currentY += levelHeight * 0.7;
}
};
const boundaryX = 450; const boundaryZ = 280; const spacing = 45;
for (let i = -boundaryX; i <= boundaryX; i += spacing) {
createTree(i + Math.random() * 15, -60 - Math.random() * 15);
createTree(i + Math.random() * 20, -100 - Math.random() * 30);
createTree(i + Math.random() * 25, -150 - Math.random() * 50);
}
for (let i = -boundaryX; i <= boundaryX; i += spacing) {
createTree(i + Math.random() * 15, boundaryZ + Math.random() * 15);
createTree(i + Math.random() * 20, boundaryZ + 40 + Math.random() * 30);
}
for (let i = -150; i <= boundaryZ + 40; i += spacing) {
createTree(-boundaryX + Math.random() * 15, i);
createTree(-boundaryX - 40 + Math.random() * 20, i);
}
for (let i = -150; i <= boundaryZ + 40; i += spacing) {
createTree(boundaryX + Math.random() * 15, i);
createTree(boundaryX + 40 + Math.random() * 20, i);
}
const gapFillCount = 25;
for (let i = 0; i < gapFillCount; i++) {
const x = -280 + (Math.random() - 0.5) * 120;
const z = 150 + (Math.random() - 0.5) * 150;
createTree(x, z, 1.0 + Math.random() * 0.2);
}
const roadSideSpacing = 60;
for (let z = roadStartZ + 50; z < roadEndZ - 100; z += roadSideSpacing) {
const leftX = -(roadWidth/2 + roadClearance + Math.random() * 15 + 20);
createTree(leftX, z + Math.random() * 20 - 10);
const rightX = (roadWidth/2 + roadClearance + Math.random() * 15 + 20);
createTree(rightX, z + Math.random() * 20 - 10);
}
const backgroundDistance = 750; const bgSpacing = 12; const bgLayers = 4; const bgScale = 2.5;
const angleStep = Math.PI / 180 * bgSpacing;
for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {
for (let layer = 0; layer < bgLayers; layer++) {
const layerOffset = layer * 50;
const distance = backgroundDistance - layerOffset + (Math.random() - 0.5) * 60;
const angleNoise = (Math.random() - 0.5) * angleStep * 0.8;
const currentAngle = angle + angleNoise;
const x = Math.cos(currentAngle) * distance;
const z = Math.sin(currentAngle) * distance;
const scale = bgScale + (Math.random() * 1.0);
createTree(x, z, scale, true);
}
}
}
function createStars() {
const geometry = new THREE.BufferGeometry();
const vertices = [];
const distributionRadius = 4900;
for (let i = 0; i < 400; i++) {
const x = Math.random() * distributionRadius - distributionRadius/2;
const y = Math.random() * 200 + 150;
const z = Math.random() * distributionRadius - distributionRadius/2;
if (Math.sqrt(x*x + z*z) > 150) { vertices.push(x, y, z); }
}
geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
const material = new THREE.PointsMaterial({ color: 0xffffff, size: 3, sizeAttenuation: false, transparent: true, opacity: 0.6, fog: false });
const stars = new THREE.Points(geometry, material);
scene.add(stars);
}
function setupEventListeners() {
window.addEventListener('resize', onWindowResize, false);
document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);
renderer.domElement.addEventListener('mousedown', onDesktopDragStart, false);
document.addEventListener('mousemove', onDesktopDragMove, false);
document.addEventListener('mouseup', onDesktopDragEnd, false);
renderer.domElement.addEventListener('click', onMouseClick, false);
renderer.domElement.addEventListener('touchstart', onTouchStart, {passive: false});
document.addEventListener('touchmove', onTouchMove, {passive: false});
document.addEventListener('touchend', onTouchEnd, false);
document.addEventListener('touchcancel', onTouchEnd, false);
document.querySelectorAll('.close-btn').forEach(btn => {
btn.addEventListener('click', hideAllOverlays, false);
});
document.querySelectorAll('.scene-overlay').forEach(overlay => {
overlay.addEventListener('click', function(event) {
if (event.target === this) { hideAllOverlays(); }
}, false);
});
const jumpBtn = document.getElementById('jump-btn');
jumpBtn.addEventListener('touchstart', (e) => {
e.preventDefault(); e.stopPropagation(); keys[' '] = true; jumpBtn.classList.add('active');
});
jumpBtn.addEventListener('touchend', (e) => {
e.preventDefault(); e.stopPropagation(); keys[' '] = false; jumpBtn.classList.remove('active');
});
jumpBtn.addEventListener('mousedown', (e) => e.preventDefault());
}
function onWindowResize() {
const width = window.innerWidth; const height = window.innerHeight;
const dpr = window.devicePixelRatio || 1;
let effectiveDPR;
if (isIPad()) { effectiveDPR = 1.0; }
else if (isMobileDevice()) { effectiveDPR = Math.min(1.5, dpr); }
else { effectiveDPR = dpr; }
renderer.setPixelRatio(effectiveDPR);
camera.aspect = width / height;
camera.updateProjectionMatrix();
renderer.setSize(width, height);
composer.setSize(width, height);
const currentDPR = renderer.getPixelRatio();
if (pixelPass && pixelPass.uniforms.resolution) {
pixelPass.uniforms.resolution.value.set(width * currentDPR, height * currentDPR);
pixelPass.uniforms.pixelSize.value = getPixelSize();
}
if (pongGame && !isSceneActive && document.getElementById('miniGamesOverlay').style.display !== 'none') {
setTimeout(() => pongGame.resizeCanvas(), 100);
}
initJoystick();
if (isSceneActive) {
document.getElementById('coin-counter').style.display = 'block';
if (isMobileDevice()) {
document.getElementById('mobile-controls').style.display = 'flex';
document.getElementById('instructions').style.display = 'none';
} else {
document.getElementById('mobile-controls').style.display = 'none';
document.getElementById('instructions').style.display = 'block';
}
}
}
function onKeyDown(event) {
if (event.key === 'Escape' && !isSceneActive) { hideAllOverlays(); return; }
if (pongGame && pongGame.isRunning) { return; }
if (!isSceneActive) return;
if (keys.hasOwnProperty(event.key.toLowerCase())) {
keys[event.key.toLowerCase()] = true;
event.preventDefault();
}
if(event.key === ' '){ keys[' '] = true; event.preventDefault(); }
}
function onKeyUp(event) {
if (keys.hasOwnProperty(event.key.toLowerCase())) { keys[event.key.toLowerCase()] = false; }
if(event.key === ' '){ keys[' '] = false; }
}
function onDesktopDragStart(event) {
if (!isSceneActive || isMobileDevice()) return;
isDragging = true;
dragStart.x = event.clientX; dragStart.y = event.clientY;
document.body.style.cursor = 'grabbing';
}
function onDesktopDragMove(event) {
if (!isDragging || !isSceneActive || isMobileDevice()) return;
const deltaX = event.clientX - dragStart.x;
const deltaY = event.clientY - dragStart.y;
const speed = 0.003;
handleRotation(deltaX, deltaY, speed);
dragStart.x = event.clientX; dragStart.y = event.clientY;
}
function onDesktopDragEnd() {
if (isMobileDevice()) return;
isDragging = false;
if (isSceneActive) { document.body.style.cursor = 'grab'; }
}
function onTouchStart(event) {
if (!isSceneActive || !isMobileDevice()) return;
if (event.changedTouches.length > 0) {
const touch = event.changedTouches[0];
dragStart.tapX = touch.clientX; dragStart.tapY = touch.clientY;
dragStart.tapTime = Date.now();
}
if (lookTouchId !== null) return;
for (const touch of event.changedTouches) {
event.preventDefault();
isDragging = true;
lookTouchId = touch.identifier;
dragStart.x = touch.clientX; dragStart.y = touch.clientY;
break;
}
}
function onTouchMove(event) {
if (!isDragging || !isSceneActive || !isMobileDevice() || lookTouchId === null) return;
for (const touch of event.touches) {
if (touch.identifier === lookTouchId) {
event.preventDefault();
const deltaX = touch.clientX - dragStart.x;
const deltaY = touch.clientY - dragStart.y;
const speed = 0.006;
handleRotation(deltaX, deltaY, speed);
dragStart.x = touch.clientX; dragStart.y = touch.clientY;
break;
}
}
}
function onTouchEnd(event) {
if (!isMobileDevice()) return;
if (event.changedTouches.length > 0 && isSceneActive) {
const touch = event.changedTouches[0];
const tapDuration = Date.now() - (dragStart.tapTime || 0);
const tapDistance = Math.sqrt(
Math.pow(touch.clientX - (dragStart.tapX || 0), 2) +
Math.pow(touch.clientY - (dragStart.tapY || 0), 2)
);
if (tapDuration < 300 && tapDistance < 10) {
mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(clickableObjects);
if (intersects.length > 0) {
const object = intersects[0].object;
console.log(`Mobile tap - Navigating to: ${object.name}`);
switch(object.name) {
case 'resume': showOverlay('resumeOverlay'); break;
case 'tshirts': showOverlay('tshirtsOverlay'); break;
case 'projects': showOverlay('projectsOverlay'); break;
case 'askjohn': showOverlay('askJohnOverlay'); break;
case 'minigames': showOverlay('miniGamesOverlay'); break;
}
}
}
}
for (const touch of event.changedTouches) {
if (touch.identifier === lookTouchId) {
isDragging = false; lookTouchId = null; break;
}
}
}
function handleRotation(deltaX, deltaY, speed) {
cameraRig.rotation.y -= deltaX * speed;
cameraPitch.rotation.x -= deltaY * speed;
const maxPitch = Math.PI / 2.5;
cameraPitch.rotation.x = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch.rotation.x));
}
function onMouseClick(event) {
if (!isSceneActive) return;
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) { return; }
event.preventDefault();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);
const intersects = raycaster.intersectObjects(clickableObjects);
if (intersects.length > 0) {
const object = intersects[0].object;
console.log(`Navigating to: ${object.name}`);
switch(object.name) {
case 'resume': showOverlay('resumeOverlay'); break;
case 'tshirts': showOverlay('tshirtsOverlay'); break;
case 'projects': showOverlay('projectsOverlay'); break;
case 'askjohn': showOverlay('askJohnOverlay'); break;
case 'minigames': showOverlay('miniGamesOverlay'); break;
}
}
}
function updatePlayerMovement(delta) {
const moveSpeed = 35.0;
const actualSpeed = moveSpeed * delta;
const forward = new THREE.Vector3();
const right = new THREE.Vector3();
cameraRig.getWorldDirection(forward);
forward.y = 0; forward.normalize();
right.crossVectors(cameraRig.up, forward).normalize();
if (keys.w || keys.ArrowUp) { cameraRig.position.addScaledVector(forward, -actualSpeed); }
if (keys.s || keys.ArrowDown) { cameraRig.position.addScaledVector(forward, actualSpeed); }
if (keys.a || keys.ArrowLeft) { cameraRig.position.addScaledVector(right, -actualSpeed); }
if (keys.d || keys.ArrowRight) { cameraRig.position.addScaledVector(right, actualSpeed); }
if (Math.abs(joystickInput.x) > 0.05 || Math.abs(joystickInput.y) > 0.05) {
cameraRig.position.addScaledVector(forward, -joystickInput.y * actualSpeed);
cameraRig.position.addScaledVector(right, joystickInput.x * actualSpeed);
}
if (keys[' '] && !isJumping) {
isJumping = true; yVelocity = jumpForce;
}
if (isJumping) {
yVelocity += gravity * delta;
cameraRig.position.y += yVelocity * delta;
if (cameraRig.position.y <= playerHeight) {
cameraRig.position.y = playerHeight;
isJumping = false; yVelocity = 0;
}
}
}
function animate() {
requestAnimationFrame(animate);
const delta = clock.getDelta();
const time = clock.getElapsedTime();
if (isSceneActive) {
updatePlayerMovement(delta);
updateCoins(delta, time);
}
updateFireworks(delta);
if (isSceneActive || fireworks.length > 0) {
composer.render();
}
}
document.fonts.ready.then(() => {
init();
}).catch((error) => {
console.error("Error loading fonts:", error);
init();
});
</script>
</body>
</html>
