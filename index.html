<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>John Gresh : Portfolio Web Game</title><link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
body{margin:0;overflow:hidden;background-color:#000;cursor:grab;-webkit-overflow-scrolling:touch;overscroll-behavior:none;font-family:'VT323', monospace;}
canvas{display:block;touch-action:none;}
#i{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);color:rgba(255, 255, 255, 0.9);font-size:18px;text-shadow:2px 2px 4px black;pointer-events:none;text-align:center;padding:10px;background:rgba(0, 0, 0, 0.5);z-index:10;}
#cc{position:absolute;top:20px;right:20px;color:#ffd700;font-size:36px;text-shadow:3px 3px 0px black;padding:10px 20px;background:rgba(26, 5, 58, 0.8);border:4px solid black;z-index:15;display:block;box-shadow:5px 5px 0px rgba(0,0,0,0.8);pointer-events:none;}
#jot{position:absolute;top:15px;left:15px;font-size:18px;color:#ffa700;display:flex;align-items:center;z-index:1;text-shadow:2px 2px 0px rgba(0,0,0,0.5);cursor:pointer;user-select:none;}
#pmc{display:none;}
.ccb{width:18px;height:18px;background-color:#2a1a3d;border:3px solid #000;margin-right:8px;display:inline-block;position:relative;box-shadow:2px 2px 0px rgba(0,0,0,0.8);}
#pmc:checked + .ccb{background-color:#e63946;}
#pmc:checked + .ccb::after{content:'X';position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);color:white;font-size:16px;}
#pwdm{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.8);display:none;justify-content:center;align-items:center;z-index:1005;}
.mc{background-color:#1a1a2e;padding:30px;border:4px solid #000;box-shadow:0 0 50px rgba(255, 167, 0, 0.9);color:white;text-align:center;width:80%;max-width:400px;}
.mc p{font-size:22px;margin-bottom:20px;}
#pwdi{width:100%;padding:10px;margin-bottom:20px;font-family:'VT323', monospace;font-size:20px;background-color:#2a1a3d;color:white;border:3px solid #000;box-sizing:border-box;}
#pwde{color:#e63946;font-size:18px;margin-bottom:15px;display:none;}
.mb{padding:10px 20px;font-family:'VT323', monospace;font-size:20px;border:3px solid #000;cursor:pointer;margin:0 10px;box-shadow:4px 4px 0px rgba(0,0,0,0.8);transition:transform 0.1s, box-shadow 0.1s;}
.mb:active{transform:translate(2px, 2px);box-shadow:2px 2px 0px rgba(0,0,0,0.8);}
#spb{background-color:#2a9d8f;color:white;}
#cpb{background-color:#6c6383;color:white;}
.so{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(26, 5, 58, 0.9);z-index:1000;display:none;justify-content:center;align-items:center;backdrop-filter:blur(3px);box-sizing:border-box;}
.oc{width:85%;max-width:1100px;height:85vh;overflow-y:auto;padding:30px;border:4px solid #000;box-shadow:0 0 50px rgba(255, 125, 92, 0.9);background-color:#1a1a2e;color:#fff;line-height:1.3;box-sizing:border-box;transition:background-color 0.3s, box-shadow 0.3s;}
#tc{max-width:650px;height:auto;max-height:85vh;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;box-shadow:0 0 50px rgba(0, 119, 182, 0.9);}
#ajc{max-width:800px;height:100%;display:flex;flex-direction:column;justify-content:space-between;align-items:center;text-align:left;box-shadow:0 0 50px rgba(255, 167, 0, 0.9);overflow-y:hidden;position:relative;}
#ajc.pa{background-color:#0a0000;box-shadow:0 0 60px rgba(230, 57, 70, 0.9);background-image:repeating-linear-gradient(45deg, rgba(80, 0, 0, 0.5) 0, rgba(80, 0, 0, 0.5) 5px, transparent 5px, transparent 10px), repeating-linear-gradient(-45deg, rgba(80, 0, 0, 0.3) 0, rgba(80, 0, 0, 0.3) 8px, transparent 8px, transparent 16px);}
#ajc.pa .rh h1{color:#e63946;}
#ajc.pa .rh p{color:#ff9999;}
#ajc.pa #cw{background-color:#1a0000;}
#ajc.pa #cw::-webkit-scrollbar-thumb{background:#e63946;}
#ajc.pa #cw::-webkit-scrollbar-thumb:hover{background:#ff5a5f;}
#ajc.pa #ci{background-color:#0a0000;border-color:#e63946;}
#ajc.pa #ci:focus{border-color:#ff5a5f;}
#ajc.pa #sb{background-color:#e63946;color:white;}
#ajc.pa #sb:hover{background-color:#ff5a5f;}
#ajc.pa #jot{color:#e63946;}
#uta{width:100%;text-align:center;margin-top:10px;margin-bottom:-10px;display:none;}
#ajc.pa #uta{display:block;}
#utb{font-family:'VT323', monospace;font-size:18px;color:#f00;background:0;border:none;cursor:pointer;text-shadow:0 0 5px #f00, 0 0 10px #f00;transition:text-shadow 0.3s, color 0.3s;padding:5px 10px;}
#utb:hover{color:#fff;text-shadow:0 0 10px #f00, 0 0 20px #f00;}
#utb:disabled{cursor:not-allowed;opacity:0.5;text-shadow:none;color:#6c6383;}
.sm{font-size:16px;color:#0f0;background-color:rgba(0, 0, 0, 0.7);padding:5px;margin:2px 0;white-space:pre-wrap;align-self:center;text-align:left;border-radius:3px;width:90%;}
.il{font-size:18px;color:#ffc107;margin-bottom:5px;font-weight:bold;text-align:left;display:block;}
#ajc.pa .il{color:#ff5a5f;}
#mgc{box-shadow:0 0 50px rgba(106, 13, 173, 0.9);display:flex;flex-direction:column;justify-content:flex-start;align-items:center;text-align:center;}
.cb{position:fixed;top:20px;right:20px;padding:10px 20px;font-size:24px;background-color:#e63946;color:white;border:3px solid black;cursor:pointer;border-radius:0;box-shadow:5px 5px 0px rgba(0,0,0,0.8);transition:background-color 0.1s, transform 0.1s, box-shadow 0.1s;z-index:1001;}
.cb:hover{background-color:#ff5a5f;}
.cb:active{transform:translate(3px, 3px);box-shadow:2px 2px 0px rgba(0,0,0,0.8);}
.oc::-webkit-scrollbar{width:14px;}
.oc::-webkit-scrollbar-track{background:#2a1a3d;border-left:2px solid black;}
.oc::-webkit-scrollbar-thumb{background:#6c6383;border:2px solid black;border-radius:0;}
.oc::-webkit-scrollbar-thumb:hover{background:#8a505d;}
.rh{text-align:center;margin-bottom:30px;border-bottom:4px dashed #6c6383;padding-bottom:20px;width:100%;position:relative;}
.rh h1{font-size:48px;margin:0;color:#ff7d5c;text-shadow:3px 3px 0px rgba(0,0,0,0.5);}
#tc .rh h1{color:#0077b6;}
#ajc .rh h1{color:#ffa700;}
#mgc .rh h1{color:#9d4edd;}
.rh p{font-size:22px;margin:5px 0 0;color:#d4a3a3;}
.rs{margin-bottom:30px;}
.rs h2{font-size:30px;color:#2a9d8f;border-bottom:2px solid #2a9d8f;padding-bottom:5px;margin-bottom:15px;text-transform:uppercase;}
.j, .ei{margin-bottom:20px;padding-left:10px;}
.jt, .dt{font-size:26px;color:#e63946;}
.co, .sc{font-size:22px;color:#fff;}
.da{font-size:20px;color:#a37c7c;display:block;margin-bottom:8px;}
.rl, .sl{font-size:21px;list-style:none;padding:0;margin:0;color:#fdf6e3;}
.rl li, .sl li{position:relative;padding-left:20px;margin-bottom:5px;}
.rl li:before, .sl li:before{content:'>';position:absolute;left:0;color:#0077b6;}
.rlo{display:flex;flex-wrap:wrap;gap:30px;}
.lm{flex:2;min-width:300px;}
.ls{flex:1;min-width:250px;}
.pc{width:90%;background-color:#2a1a3d;border:4px solid #000;margin:25px 0;box-shadow:5px 5px 0px rgba(0,0,0,0.8);}
.pb{background-color:#0077b6;height:35px;width:60%;background-image:linear-gradient(90deg, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.25) 5%, transparent 5%, transparent 100%);background-size:20px 100%;}
.lt{font-size:28px;color:#fff;margin-top:15px;}
#ctc{display:flex;flex-direction:column;width:100%;flex-grow:1;overflow:hidden;min-height:0;}
#cw{flex-grow:1;background-color:#2a1a3d;border:4px solid #000;padding:15px;overflow-y:auto;margin-bottom:15px;box-shadow:inset 0 0 10px rgba(0,0,0,0.5);display:flex;flex-direction:column;min-height:0;transition:background-color 0.3s;}
#cw::-webkit-scrollbar{width:14px;}
#cw::-webkit-scrollbar-track{background:#1a1a2e;border-left:2px solid black;}
#cw::-webkit-scrollbar-thumb{background:#ffa700;border:2px solid black;border-radius:0;}
#cw::-webkit-scrollbar-thumb:hover{background:#ffc107;}
#cm{display:flex;flex-direction:column;gap:15px;}
.msg{padding:10px 15px;border:3px solid #000;max-width:80%;word-wrap:break-word;font-size:20px;line-height:1.4;}
.um{align-self:flex-end;background-color:#0077b6;color:white;box-shadow:5px 5px 0px rgba(0,0,0,0.8);}
.bm{align-self:flex-start;background-color:#e63946;color:white;box-shadow:-5px 5px 0px rgba(0,0,0,0.8);}
#cia{display:flex;gap:10px;}
#ci{flex-grow:1;padding:10px 15px;font-family:'VT323', monospace;font-size:22px;background-color:#1a1a2e;color:#fff;border:4px solid #000;box-shadow:5px 5px 0px rgba(0,0,0,0.8);transition:background-color 0.3s, border-color 0.3s;}
#ci:focus{outline:none;border-color:#ffa700;}
#sb{padding:10px 20px;font-family:'VT323', monospace;font-size:22px;background-color:#ffa700;color:black;border:4px solid #000;cursor:pointer;box-shadow:5px 5px 0px rgba(0,0,0,0.8);transition:background-color 0.1s, transform 0.1s, box-shadow 0.1s;}
#sb:hover{background-color:#ffc107;}
#sb:active{transform:translate(3px, 3px);box-shadow:2px 2px 0px rgba(0,0,0,0.8);}
#sb:disabled{background-color:#6c6383;cursor:not-allowed;transform:none;box-shadow:5px 5px 0px rgba(0,0,0,0.8);}
#mctrl{position:fixed;bottom:0;left:0;width:100%;height:200px;z-index:20;display:none;justify-content:space-between;align-items:center;padding:0 20px;box-sizing:border-box;pointer-events:none;}
#jz{position:relative;width:150px;height:150px;pointer-events:auto;margin-left:20px;touch-action:none;}
#ab{display:flex;gap:20px;pointer-events:auto;margin-right:40px;touch-action:none;}
.abtn{width:90px;height:90px;border-radius:50%;background:rgba(255, 69, 0, 0.5);border:3px solid rgba(255, 255, 255, 0.7);color:white;font-size:24px;display:flex;justify-content:center;align-items:center;user-select:none;transition:background-color 0.1s, transform 0.1s, box-shadow 0.1s;touch-action:none;}
.abtn:active, .abtn.active{background:rgba(255, 69, 0, 0.8);transform:scale(0.95);}
#pcan{background-color:#000;border:4px solid #9d4edd;display:block;margin:0 auto 20px auto;cursor:ns-resize;touch-action:none;}
#psc{font-size:36px;color:#fff;text-align:center;margin-bottom:15px;}
#pin{text-align:center;font-size:20px;margin-top:5px;color:#d4a3a3;padding-bottom:20px;}
#prm{position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);font-size:36px;color:#ff7d5c;background-color:rgba(26, 5, 58, 0.95);padding:20px 40px;border:3px solid #ff7d5c;display:none;z-index:1002;text-align:center;white-space:nowrap;box-shadow:0 0 30px rgba(255, 125, 92, 0.7);}
@media (max-width: 800px){
#i{display:none;}
#cc{font-size:20px;top:10px;right:10px;padding:4px 8px;}
.cb{top:10px;right:10px;padding:8px 16px;font-size:20px;border:3px solid black;box-shadow:3px 3px 0px rgba(0,0,0,0.8);}
.cb:active{transform:translate(1px, 1px);box-shadow:1px 1px 0px rgba(0,0,0,0.8);}
#jot{font-size:16px;top:10px;left:10px;}
.oc{width:95%;padding:15px;height:85vh;max-height:calc(100vh - 60px);}
.rh h1{font-size:36px;}
#psc{font-size:28px;}
#prm{font-size:24px;padding:15px 25px;white-space:normal;}
#ci, #sb{font-size:18px;padding:8px 12px;}
#utb{font-size:16px;padding:5px 10px;}
}
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px){
.cb{position:fixed!important;z-index:1001!important;top:15px!important;right:15px!important;padding:12px 24px!important;font-size:26px!important;background-color:#e63946!important;border:4px solid black!important;}
.oc{height:85vh!important;max-height:calc(100vh - 90px)!important;}
}
</style>
</head>
<body>
<div id="i">WASD/Arrows: Move | Space: Jump | Drag: Look<br>Click the store signs. Find the hidden coins!</div><div id="cc">COINS: 0 / 6</div>
<div id="pwdm"><div class="mc"><p>Enter Password for Access:</p><input type="password" id="pwdi" placeholder="> ********"><div id="pwde">ACCESS DENIED</div><button id="spb" class="mb">SUBMIT</button><button id="cpb" class="mb">CANCEL</button></div></div>
<div id="ro" class="so"><button class="cb">[X] BACK</button><div id="rc" class="oc"><div class="rh"><h1>John Gresh</h1><p>(336) 995-4119 | johngresh.usa@gmail.com</p></div><div class="rlo"><div class="lm"><section class="rs"><h2>Experience</h2><div class="j"><div class="jt">Maintenance Technician</div><div class="co">Toyota Battery Factory</div><span class="da">July 2024 - November 2024</span><ul class="rl"><li>General Maintenance</li><li>Preventative Maintenance</li><li>Work orders/Cost Center Management</li><li>Performing Job Safety Analysis</li></ul></div><div class="j"><div class="jt">Assistant Manager</div><div class="co">New Balance</div><span class="da">October 2021 - Current</span><ul class="rl"><li>Assisting in the general operation of the store</li><li>Opening and closing the store</li><li>Overseeing the customer experience</li><li>Fitting customers for shoes</li></ul></div><div class="j"><div class="jt">Sales Representative</div><div class="co">GNC</div><span class="da">March 2019 - July 2019, Charlotte NC</span><ul class="rl"><li>Opening/Closing store</li><li>Inventory checks</li><li>Customer relations</li><li>Register</li><li>Cleaning</li></ul></div><div class="j"><div class="jt">Lifeguard</div><div class="co">Forsyth Country Club</div><span class="da">2016 - 2017 Summer</span><ul class="rl"><li>Lifeguarding</li><li>Checking in guests</li><li>Cleaning pool deck and pool services</li><li>Testing pool chemicals/Adding chemicals</li><li>Strong emphasis on customer relations</li></ul></div><div class="j"><div class="jt">Bussing tables / working in kitchen</div><div class="co">Vincenzo's Restaurant</div><span class="da">January 2015 - December 2015, Winston-salem NC</span><ul class="rl"><li>Making bread/Cleaning dishes/Making salads/ Bus Boy</li><li>Cleaning station</li><li>Customer relations</li></ul></div></section></div><div class="ls"><section class="rs"><h2>Education</h2><div class="ei"><div class="dt">Mechatronics Technician</div><div class="sc">Forsyth Tech</div><span class="da">August 2022 - May 2024, Winston Salem NC</span></div><div class="ei"><div class="dt">Internship</div><div class="sc">ThinkPLC</div><span class="da">August 2022 - May 2023, Winston Salem NC</span></div><div class="ei"><div class="dt">High School Diploma</div><div class="sc">Mount Tabor</div><span class="da">August 2013 - May 2017, Winston Salem NC</span></div></section><section class="rs"><h2>Skills</h2><ul class="sl"><li>OSHA 10-Hr Certified</li><li>Electrical Safe Work Practices Certified</li><li>Control of Hazardous Energy Certified</li><li>PLC installation / proficient</li><li>PLC programming (RSLogix) / proficient</li><li>Python / proficient</li><li>C++ / beginner</li><li>Matlab / beginner</li><li>Sales experience (GNC, New Balance)</li><li>Cell phone and electronic repair (iPhone/Mac)</li></ul></section></div></div></div></div>
<div id="po" class="so"><button class="cb">[X] BACK</button><div id="pc" class="oc"><div class="rh"><h1>Projects</h1></div><section class="rs"><h2>Featured Work</h2><ul class="sl"><li>This Website</li></ul></section></div></div>
<div id="to" class="so"><button class="cb">[X] BACK</button><div id="tc" class="oc"><div class="rh"><h1>T-Shirt Store (WIP)</h1></div><p class="lt">Initializing Storefront...</p><div class="pc"><div class="pb"></div></div><p class="lt">> later this week</p></div></div>
<div id="ajo" class="so"><button class="cb">[X] BACK</button><div id="ajc" class="oc"><div class="rh"><div id="jot"><input type="checkbox" id="pmc"><span class="ccb"></span><label for="pmc">John Gresh Only</label></div><h1>Ask John (AI)</h1><p>Chat with an AI trained on John's professional background.</p></div><div id="ctc"><div id="cw"><div id="cm"></div></div><div id="cia"><input type="text" id="ci" placeholder="Type your question..."><button id="sb">SEND</button></div><div id="uta"><button id="utb">[ UltraThink ]</button></div></div></div></div>
<div id="mgo" class="so"><button class="cb">[X] BACK</button><div id="mgc" class="oc"><div class="rh"><h1>Pong AI</h1></div><div id="psc">Player: <span id="ppsc">0</span> | AI: <span id="pasc">0</span> | Round: <span id="prnd">1</span></div><canvas id="pcan"></canvas><div id="pin"><p>First to 5 wins the round. The AI adapts each round!</p><p>Desktop: Use Mouse or W/S/Up/Down Arrows.</p><p>Mobile: Drag your paddle.</p></div></div></div>
<div id="prm"></div><div id="mctrl"><div id="jz"></div><div id="ab"><div id="jb" class="abtn">JUMP</div></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
<script id="pvs" type="x-shader/x-vertex">varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}</script>
<script id="pfs" type="x-shader/x-fragment">uniform sampler2D tDiffuse;uniform vec2 resolution;uniform float pixelSize;varying vec2 vUv;void main(){vec2 dxy=pixelSize/resolution;vec2 coord=dxy*floor(vUv/dxy+0.5);gl_FragColor=texture2D(tDiffuse,coord);}</script>
<script id="svs" type="x-shader/x-vertex">varying vec3 vWorldPosition;void main(){vec4 worldPosition=modelMatrix*vec4(position,1.0);vWorldPosition=worldPosition.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}</script>
<script id="sfs" type="x-shader/x-fragment">
uniform vec3 cZ;uniform vec3 cHB;uniform vec3 cHD;uniform vec3 sD;varying vec3 vWorldPosition;
void main(){
vec3 d=normalize(vWorldPosition);float h=max(0.0,d.y);float vF=pow(1.0-h,2.5);
float sA=dot(d,sD);float hF=(sA+1.0)*0.5;hF=smoothstep(0.3,0.7,hF);
vec3 bHC=mix(cHD,cHB,hF);vec3 sC=mix(cZ,bHC,vF);
float sH=max(0.0,sA);sH=pow(sH,32.0);
sC+=vec3(1.0,0.9,0.7)*sH*0.8;gl_FragColor=vec4(sC,1.0);
}</script>
<script>
let S, Cam, R, Comp, PP, cR, cP, Ray, M;
const cO = [], Clk = new THREE.Clock(), K = {ArrowUp:!1, ArrowDown:!1, ArrowLeft:!1, ArrowRight:!1, w:!1, a:!1, s:!1, d:!1, ' ':!1};
let JSI = {x:0, y:0}, iD = !1, dS = {x:0, y:0}, lTI = null, iSA = !0;
const Coins = []; let cC = 0; const T_COINS = 6;
let cG, cMtls; const FW = []; let fT = null;
const pHt = 10; let iJmp = !1, yV = 0; const Gv = -80, jF = 30;
const R_CFG = {w:36, l:1500, sZ:260, sW:10}; R_CFG.eZ = R_CFG.sZ + R_CFG.l;
const T_CFG = {sZ:350, l:500, w:50, h:35, wT:10, cW:180}; T_CFG.eZ = T_CFG.sZ + T_CFG.l;
const C = {
sZ:0x1a053a, sHD:0x2a1a3d, hG:0xff7d5c, asph:0x1a1a2e, aL:0x6c6383, brk:0x8a505d, grs:0x182c25, stc:0xd4a3a3, stcD:0xa37c7c, wGB:0xfff5c3,
wGD:0x839db5, sR:0xe63946, sT:0x0077b6, sP:0x2a9d8f, sAJ:0xffa700, sMG:0x6a0dad, bG:0xffe8a3, bT:0xd95763, tD:0x1b3028, tT:0x4a3f35,
mD:0x1a1a2e, pM:0x4a4f63, pG:0xffe0a3, cGld:0xffd700, cDG:0xc6a100, tC:0x3a3a4a, tF:0x5a5a6a, tL:0xffa050
};
const sDV = new THREE.Vector3(-1, 0.25, -0.8).normalize();
function isMob() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800; }
function isPad() { return /iPad/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }

class PG {
constructor(cId) {
this.C = document.getElementById(cId); this.ctx = this.C.getContext('2d');
this.Run = !1; this.aFId = null; this.Srv = !1; this.sTId = null;
this.W = 640; this.H = 400; this.C.width = this.W; this.C.height = this.H;
this.pW = 10; this.pH = 80; this.pS = 8; this.bS = 10;
this.bBS = isMob() ? 6 : 5; this.Rnd = 1; this.aBS = 4; this.aRF = 0.1; this.aEM = 35;
this.P = {x:this.pW, y:this.H/2 - this.pH/2, w:this.pW, h:this.pH, s:0};
this.A = {x:this.W - this.pW*2, y:this.H/2 - this.pH/2, w:this.pW, h:this.pH, s:0, tY:this.H/2};
this.B = {x:this.W/2, y:this.H/2, w:this.bS, h:this.bS, dx:0, dy:0, speed:this.bBS};
this.pK = {ArrowUp:!1, ArrowDown:!1, W:!1, S:!1}; this.iDP = !1;
this.sEL(); this.rG();
}
aD() {
this.aBS = 4 + this.Rnd*0.5; this.aRF = Math.min(0.9, 0.1 + this.Rnd*0.08);
this.aEM = Math.max(5, 35 - this.Rnd*4); this.B.speed = this.bBS + this.Rnd*0.3;
}
sEL() {
document.addEventListener('keydown', (e) => {
if (document.activeElement.id === 'ci' || document.activeElement.id === 'pwdi') return;
if (this.Run) {
if (e.key === 'ArrowUp') { this.pK.ArrowUp = !0; e.preventDefault(); }
if (e.key === 'ArrowDown') { this.pK.ArrowDown = !0; e.preventDefault(); }
if (e.key === 'w' || e.key === 'W') { this.pK.W = !0; e.preventDefault(); }
if (e.key === 's' || e.key === 'S') { this.pK.S = !0; e.preventDefault(); }
}});
document.addEventListener('keyup', (e) => {
if (e.key === 'ArrowUp') this.pK.ArrowUp = !1;
if (e.key === 'ArrowDown') this.pK.ArrowDown = !1;
if (e.key === 'w' || e.key === 'W') this.pK.W = !1;
if (e.key === 's' || e.key === 'S') this.pK.S = !1;
});
this.C.addEventListener('mousemove', (e) => { if (this.Run && !isMob()) this.hPM(e.clientY); });
this.C.addEventListener('touchstart', (e) => { if (this.Run) { e.preventDefault(); this.iDP = !0; this.hPM(e.touches[0].clientY); }}, {passive:!1});
this.C.addEventListener('touchmove', (e) => { if (this.Run && this.iDP) { e.preventDefault(); this.hPM(e.touches[0].clientY); }}, {passive:!1});
this.C.addEventListener('touchend', () => { this.iDP = !1; });
}
hPM(cY) {
const rect = this.C.getBoundingClientRect(), sY = this.H / rect.height;
let pY = (cY - rect.top) * sY; this.P.y = pY - this.P.h/2;
}
rB(s) {
if (this.sTId) { clearTimeout(this.sTId); this.sTId = null; }
this.B.x = this.W/2 - this.B.w/2; this.B.y = this.H/2 - this.B.h/2;
this.B.dx = 0; this.B.dy = 0; this.Srv = !0;
this.sTId = setTimeout(() => {
if (!this.Run) return;
const iSS = isMob() ? 4 : 3; let dir = (Math.random() > 0.5 ? 1 : -1);
if (s === 'ai') dir = -1; if (s === 'player') dir = 1;
this.B.dx = iSS * dir; this.B.dy = iSS * (Math.random()*1.4 - 0.7);
this.Srv = !1; this.sTId = null;
}, 1500);
}
rG() { this.P.s = 0; this.A.s = 0; this.Rnd = 1; this.aD(); this.uSD(); this.rB(null); }
St() { if (this.Run) return; this.Run = !0; this.rC(); this.L(); }
sNR() { if (this.Run) return; this.Run = !0; this.rC(); this.rB(null); this.L(); }
Sp() {
this.Run = !1;
if (this.aFId) cancelAnimationFrame(this.aFId);
if (this.sTId) { clearTimeout(this.sTId); this.sTId = null; }
}
rC() {
const ctr = document.getElementById('mgc'); if (!ctr) return;
const cW = ctr.offsetWidth, cH = ctr.offsetHeight, gAR = this.W / this.H;
const hH = ctr.querySelector('.rh')?.offsetHeight || 0;
const sH = document.getElementById('psc')?.offsetHeight || 0;
const iH = document.getElementById('pin')?.offsetHeight || 0;
const avH = cH - (hH + sH + iH + 40), avW = cW - 40;
let dW = avW, dH = dW / gAR;
if (dH > avH) { dH = avH; dW = dH * gAR; }
if (dW > 0 && dH > 0) { this.C.style.width = `${dW}px`; this.C.style.height = `${dH}px`; }
}
uSD() {
document.getElementById('ppsc').textContent = this.P.s;
document.getElementById('pasc').textContent = this.A.s;
document.getElementById('prnd').textContent = this.Rnd;
}
cWC() {
const wS = 5; let rO = !1;
if (this.P.s >= wS) { this.Rnd++; this.sRM(`You Won Round ${this.Rnd - 1}!`, `AI adapting... (Level ${this.Rnd})`); rO = !0; }
else if (this.A.s >= wS) { this.Rnd++; this.sRM(`AI Won Round ${this.Rnd - 1}!`, `AI learning... (Level ${this.Rnd})`); rO = !0; }
if (rO) { this.P.s = 0; this.A.s = 0; this.aD(); this.uSD(); this.Sp(); }
}
sRM(l1, l2) {
const mE = document.getElementById('prm');
mE.innerHTML = `${l1}<br><small>${l2}</small>`; mE.style.display = 'block';
setTimeout(() => { mE.style.display = 'none'; if (document.getElementById('mgo').style.display !== 'none') this.sNR(); }, 3500);
}
U() {
if (this.pK.ArrowUp || this.pK.W) this.P.y -= this.pS;
if (this.pK.ArrowDown || this.pK.S) this.P.y += this.pS;
if (this.P.y < 0) this.P.y = 0;
if (this.P.y + this.P.h > this.H) this.P.y = this.H - this.P.h;
if (this.B.dx > 0 && (this.B.dx !== 0 || this.B.dy !== 0)) {
if (Math.random() < this.aRF) {
let pY = this.B.y; pY += (Math.random() - 0.5) * this.aEM;
this.A.tY = pY - this.A.h/2;
}} else if (Math.random() < 0.05) this.A.tY = this.H/2 - this.A.h/2;
if (this.A.y < this.A.tY) this.A.y += Math.min(this.aBS, this.A.tY - this.A.y);
else if (this.A.y > this.A.tY) this.A.y -= Math.min(this.aBS, this.A.y - this.A.tY);
if (this.A.y < 0) this.A.y = 0;
if (this.A.y + this.A.h > this.H) this.A.y = this.H - this.A.h;
if (this.B.dx === 0 && this.B.dy === 0) return;
this.B.x += this.B.dx; this.B.y += this.B.dy;
if (this.B.y <= 0 || this.B.y + this.B.h >= this.H) {
this.B.dy *= -1;
if (this.B.y <= 0) this.B.y = 0;
if (this.B.y + this.B.h >= this.H) this.B.y = this.H - this.B.h;
}
const coll = (p, b) => p.x < b.x + b.w && p.x + p.w > b.x && p.y < b.y + b.h && p.y + p.h > b.y;
let pHit = null;
if (this.B.dx < 0 && coll(this.P, this.B)) { pHit = this.P; this.B.x = this.P.x + this.P.w; }
else if (this.B.dx > 0 && coll(this.A, this.B)) { pHit = this.A; this.B.x = this.A.x - this.B.w; }
if (pHit) {
this.Srv = !1; let rS = this.B.speed;
let cP = (this.B.y + this.B.h/2) - (pHit.y + pHit.h/2); cP = cP / (pHit.h/2);
let aR = (Math.PI/3.5) * cP; let dir = (pHit === this.P) ? 1 : -1;
this.B.dx = dir * rS * Math.cos(aR); this.B.dy = rS * Math.sin(aR);
}
if (this.B.x + this.B.w < 0) { this.A.s++; this.uSD(); this.cWC(); if (this.Run) this.rB('ai'); }
else if (this.B.x > this.W) { this.P.s++; this.uSD(); this.cWC(); if (this.Run) this.rB('player'); }
}
D() {
this.ctx.fillStyle = '#000'; this.ctx.fillRect(0, 0, this.W, this.H);
this.ctx.strokeStyle = '#4a4f63'; this.ctx.lineWidth = 4; this.ctx.setLineDash([10, 15]);
this.ctx.beginPath(); this.ctx.moveTo(this.W/2, 0); this.ctx.lineTo(this.W/2, this.H); this.ctx.stroke();
this.ctx.fillStyle = '#9d4edd'; this.ctx.fillRect(this.P.x, this.P.y, this.P.w, this.P.h);
this.ctx.fillStyle = '#e63946'; this.ctx.fillRect(this.A.x, this.A.y, this.A.w, this.A.h);
if (this.Srv && this.B.dx === 0 && this.B.dy === 0) {
if (Math.floor(Date.now()/200) % 2 === 0) { this.ctx.fillStyle = '#FFF'; this.ctx.fillRect(this.B.x, this.B.y, this.B.w, this.B.h); }
} else { this.ctx.fillStyle = '#FFF'; this.ctx.fillRect(this.B.x, this.B.y, this.B.w, this.B.h); }
}
L() { if (!this.Run) return; this.U(); this.D(); this.aFId = requestAnimationFrame(() => this.L()); }
}
let pG = null;

function I() {
S = new THREE.Scene(); S.fog = new THREE.Fog(C.hG, 600, 5000);
Cam = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 5000);
cR = new THREE.Object3D(); cP = new THREE.Object3D(); cP.add(Cam); cR.add(cP); S.add(cR);
cR.position.set(100, pHt, 130); cP.rotation.x = -0.12; cR.rotation.y = -0.50;
R = new THREE.WebGLRenderer({antialias:!1}); R.setSize(window.innerWidth, window.innerHeight);
const dpr = window.devicePixelRatio || 1; let eDPR;
if (isPad()) eDPR = 1.0; else if (isMob()) eDPR = Math.min(1.5, dpr); else eDPR = dpr;
R.setPixelRatio(eDPR); R.shadowMap.enabled = !isMob(); R.shadowMap.type = THREE.BasicShadowMap;
document.body.appendChild(R.domElement);
sPP(); sL(); iC(); cSky(); cGrd(); cBui(); cBB(); cPL(); cTun(); cTre(); cSta(); plC();
document.getElementById('cc').textContent = `COINS: 0 / ${T_COINS}`;
Ray = new THREE.Raycaster(); M = new THREE.Vector2();
sEL(); iChat(); iPM();
if (isMob()) {
document.getElementById('mctrl').style.display = 'flex';
requestAnimationFrame(() => { iJ();
if (/iPad|iPhone|iPod/.test(navigator.userAgent)) { setTimeout(() => { if (jM && jM[0]) jM[0].trigger('rested'); }, 500); }
});
} else iJ();
A();
}

function sO(oId) {
hO(); const o = document.getElementById(oId);
if (o) {
iSA = !1; o.style.display = 'flex'; R.domElement.style.pointerEvents = 'none'; document.body.style.cursor = 'default';
['i', 'mctrl', 'cc'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = 'none';
});
if (oId === 'mgo') {
if (!pG) pG = new PG('pcan');
pG.rG(); setTimeout(() => { pG.St(); }, 100);
}
if (oId === 'ajo') {
iChat(); uPUS();
setTimeout(() => { document.getElementById('ci').focus();
const cW = document.getElementById('cw'); cW.scrollTop = cW.scrollHeight;
}, 100);
}}}

function hO() {
if (pG && pG.Run) pG.Sp();
document.getElementById('prm').style.display = 'none';
document.getElementById('pwdm').style.display = 'none';
const overlays = document.querySelectorAll('.so'); let wA = !1;
overlays.forEach(o => { if (o.style.display !== 'none') { o.style.display = 'none'; wA = !0; }});
if (wA) {
iSA = !0; R.domElement.style.pointerEvents = 'auto'; document.body.style.cursor = 'grab';
iD = !1; lTI = null; document.getElementById('cc').style.display = 'block';
if (!isMob()) document.getElementById('i').style.display = 'block';
else document.getElementById('mctrl').style.display = 'flex';
}}

function gPS() {
let tVR;
if (isPad()) tVR = 240; else if (isMob()) tVR = 280; else tVR = 450;
const eDPR = R.getPixelRatio();
const cS = (window.innerHeight * eDPR) / tVR;
return Math.max(2, cS);
}
function sPP() {
Comp = new THREE.EffectComposer(R);
const rP = new THREE.RenderPass(S, Cam); Comp.addPass(rP);
const dpr = R.getPixelRatio();
PP = new THREE.ShaderPass({
uniforms: {tDiffuse:{value:null}, resolution:{value:new THREE.Vector2(window.innerWidth*dpr, window.innerHeight*dpr)}, pixelSize:{value:gPS()}},
vertexShader: document.getElementById('pvs').textContent, fragmentShader: document.getElementById('pfs').textContent
});
PP.renderToScreen = !0; Comp.addPass(PP);
}
let jM = null;
function iJ() {
if (!isMob()) { if (jM) { jM.destroy(); jM = null; } return; }
if (jM) return;
const opt = {zone:document.getElementById('jz'), mode:'static', position:{left:'50%', top:'50%'}, color:'rgba(255, 255, 255, 0.5)', size:120};
jM = nipplejs.create(opt);
jM.on('move', (e, d) => {
const a = d.angle.radian, f = Math.min(d.force, 1.0);
JSI.x = Math.cos(a)*f; JSI.y = Math.sin(a)*f;
});
jM.on('end', () => { JSI.x = 0; JSI.y = 0; });
}

function cCT(s=128) {
const can = document.createElement('canvas'); can.width = s; can.height = s;
const ctx = can.getContext('2d');
ctx.fillStyle = new THREE.Color(C.cGld).getStyle(); ctx.fillRect(0, 0, s, s);
ctx.strokeStyle = new THREE.Color(C.cDG).getStyle(); ctx.lineWidth = s*0.08;
ctx.beginPath(); ctx.arc(s/2, s/2, s/2 - ctx.lineWidth/2, 0, Math.PI*2, !0); ctx.stroke();
ctx.font = `bold ${s*0.6}px 'VT323', monospace`;
ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
ctx.fillStyle = new THREE.Color(C.cDG).getStyle(); ctx.fillText('$', s/2, s/2 + s*0.05);
const t = new THREE.CanvasTexture(can);
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function cTTS(txt, col, fS=24, bg=null) {
const can = document.createElement('canvas'); const ctx = can.getContext('2d');
can.width = 64; can.height = 64;
if (bg) { ctx.fillStyle = bg; ctx.fillRect(0, 0, 64, 64); }
ctx.font = `${fS}px 'VT323', monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
ctx.fillStyle = col; ctx.fillText(txt, 32, 32 + fS*0.1);
const t = new THREE.CanvasTexture(can);
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function iC() {
const seg = isMob() ? 8 : 12;
cG = new THREE.CylinderGeometry(2, 2, 0.6, seg);
const sM = new THREE.MeshStandardMaterial({color:C.cGld, metalness:0.8, roughness:0.5, emissive:0x4a2d00});
const cFT = cCT(128); cFT.rotation = Math.PI/2; cFT.center.set(0.5, 0.5);
const fM = new THREE.MeshStandardMaterial({map:cFT, metalness:0.8, roughness:0.3, emissive:0x4a2d00});
cMtls = [sM, fM, fM];
}
function cCoi(x, y, z) {
const coin = new THREE.Mesh(cG, cMtls);
coin.position.set(x, y, z); coin.rotation.x = Math.PI/2;
if (R.shadowMap.enabled) coin.castShadow = !0;
S.add(coin); Coins.push({mesh:coin, collected:!1, startY:y});
}
function plC() {
const cH = 6.5;
cCoi(80, cH, 100); cCoi(0, cH-2.5, -18); cCoi(-200, cH, 200);
cCoi(30, cH, T_CFG.sZ-20); cCoi(0, cH, T_CFG.sZ + T_CFG.l/2); cCoi(-45, cH, -35);
}
function uC(d, t) {
const rS = 1.5, hS = 1.8, hH = 0.3, cD = 8, pP = cR.position;
Coins.forEach(cD => {
if (!cD.collected) {
const c = cD.mesh; c.rotation.z += rS*d;
const tO = cD.startY + c.position.x + c.position.z;
c.position.y = cD.startY + Math.sin((t + tO)*hS)*hH;
if (pP.distanceTo(c.position) < cD) colC(cD);
}});
}
function colC(cD) {
if (cD.collected) return;
cD.collected = !0; S.remove(cD.mesh); cC++;
const ctr = document.getElementById('cc');
ctr.textContent = `COINS: ${cC} / ${T_COINS}`;
if (cC === T_COINS) {
ctr.style.color = "#2a9d8f"; ctr.textContent += " (ALL FOUND!)"; sFw();
}}
function cFw(x, y, z, col, life = 8.0) {
const pC = isMob() ? 80 : 150; const geo = new THREE.BufferGeometry();
const pos = new Float32Array(pC*3), vel = new Float32Array(pC*3), cols = new Float32Array(pC*3);
const bC = new THREE.Color(col);
for (let i=0; i<pC; i++) {
const idx = i*3; pos[idx] = 0; pos[idx+1] = 0; pos[idx+2] = 0;
const spd = Math.random()*30 + 15, phi = Math.random()*Math.PI*2, theta = Math.random()*Math.PI;
vel[idx] = Math.sin(theta)*Math.cos(phi)*spd;
vel[idx+1] = Math.cos(theta)*spd + 10;
vel[idx+2] = Math.sin(theta)*Math.sin(phi)*spd;
const pCol = bC.clone().multiplyScalar(Math.random()*0.5 + 0.5);
cols[idx] = pCol.r; cols[idx+1] = pCol.g; cols[idx+2] = pCol.b;
}
geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
geo.setAttribute('velocity', new THREE.BufferAttribute(vel, 3));
geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
const mat = new THREE.PointsMaterial({
size: isMob() ? 8 : 12, vertexColors:!0, blending:THREE.AdditiveBlending,
transparent:!0, depthWrite:!1, sizeAttenuation:!0
});
const p = new THREE.Points(geo, mat); p.position.set(x, y, z);
FW.push({p:p, life:life, maxLife:life}); S.add(p);
}
function sFw() {
const D=20000, I=500, Z=-100, X=200, H=60;
const Cols = [0xe63946, 0x0077b6, 0x2a9d8f, 0xffd700, 0xff7d5c, 0x9d4edd];
let sT = Date.now();
fT = setInterval(() => {
if (Date.now() - sT >= D) { clearInterval(fT); fT = null; return; }
const x=(Math.random()-0.5)*X, y=Math.random()*H+80, z=Z+(Math.random()-0.5)*50;
const c=Cols[Math.floor(Math.random()*Cols.length)];
cFw(x, y, z, c);
}, I);
}
function uFw(d) {
const pG = -40;
for (let i = FW.length-1; i >= 0; i--) {
const fw = FW[i]; fw.life -= d;
if (fw.life <= 0) {
S.remove(fw.p); fw.p.geometry.dispose(); fw.p.material.dispose();
FW.splice(i, 1); continue;
}
const pos = fw.p.geometry.attributes.position.array;
const vel = fw.p.geometry.attributes.velocity.array;
const pC = pos.length/3;
for (let j=0; j<pC; j++) {
const idx = j*3; vel[idx+1] += pG*d;
const drag = (1 - 0.8*d);
vel[idx] *= drag; vel[idx+1] *= drag; vel[idx+2] *= drag;
pos[idx] += vel[idx]*d; pos[idx+1] += vel[idx+1]*d; pos[idx+2] += vel[idx+2]*d;
}
fw.p.material.opacity = fw.life / fw.maxLife;
fw.p.geometry.attributes.position.needsUpdate = !0;
}}
function cSky() {
const u = {
cZ:{value:new THREE.Color(C.sZ)}, cHB:{value:new THREE.Color(C.hG)},
cHD:{value:new THREE.Color(C.sHD)}, sD:{value:sDV}
};
const sM = new THREE.ShaderMaterial({
vertexShader: document.getElementById('svs').textContent, fragmentShader: document.getElementById('sfs').textContent,
uniforms: u, side: THREE.BackSide, fog:!1
});
const sG = new THREE.SphereGeometry(1750, 32, 16);
const sky = new THREE.Mesh(sG, sM); S.add(sky);
}
function sL() {
const aL = new THREE.AmbientLight(0x604080, 0.35); S.add(aL);
const hL = new THREE.HemisphereLight(C.sZ, 0x8a5a6d, 0.5); S.add(hL);
const sL = new THREE.DirectionalLight(0xffa500, 0.4);
sL.position.copy(sDV.clone().multiplyScalar(300));
sL.castShadow = !0; sL.shadow.mapSize.width = 2048; sL.shadow.mapSize.height = 2048;
sL.shadow.camera.near = 0.5; sL.shadow.camera.far = 500; sL.shadow.bias = -0.005;
const sS = 180;
sL.shadow.camera.left = -sS; sL.shadow.camera.right = sS;
sL.shadow.camera.top = sS; sL.shadow.camera.bottom = -sS;
S.add(sL);
}
function cTT(txt, bgC, tC, w=256, h=128, fS=50) {
const can = document.createElement('canvas'); const ctx = can.getContext('2d');
can.width = w; can.height = h;
ctx.fillStyle = bgC; ctx.fillRect(0, 0, w, h);
ctx.font = `${fS}px 'VT323', Monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
ctx.strokeStyle = 'black'; ctx.lineWidth = 4;
ctx.strokeText(txt, w/2, h/2 + fS*0.05);
ctx.fillStyle = tC; ctx.fillText(txt, w/2, h/2 + fS*0.05);
const t = new THREE.CanvasTexture(can);
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function cST(c1, c2, sW=16) {
const can = document.createElement('canvas'); const ctx = can.getContext('2d');
can.width = sW*2; can.height = sW;
ctx.fillStyle = c1; ctx.fillRect(0, 0, sW*2, sW);
ctx.fillStyle = c2; ctx.fillRect(0, 0, sW, sW);
const t = new THREE.CanvasTexture(can);
t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function cTST(txt, w=512, h=64, fS=45) {
const can = document.createElement('canvas'); can.width = w; can.height = h;
const ctx = can.getContext('2d'); const sH = 16;
const nS = Math.ceil(h/sH);
for (let i=0; i<nS; i++) {
ctx.fillStyle = (i%2 === 0) ? '#000' : '#f7b538';
ctx.fillRect(0, i*sH, w, sH);
}
ctx.font = `${fS}px 'VT323', Monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
ctx.strokeStyle = 'black'; ctx.lineWidth = 8;
ctx.strokeText(txt, w/2, h/2);
ctx.fillStyle = 'white'; ctx.fillText(txt, w/2, h/2);
const t = new THREE.CanvasTexture(can);
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function cGT(w=32, h=32) {
const can = document.createElement('canvas'); can.width = w; can.height = h;
const ctx = can.getContext('2d'); const iD = ctx.createImageData(w, h); const d = iD.data;
const bC = new THREE.Color(C.grs);
for (let i=0; i<d.length; i+=4) {
const n = Math.random()*0.15 - 0.075; const c = bC.clone();
c.r += n; c.g += n; c.b += n;
d[i] = Math.max(0, Math.min(255, c.r*255)); d[i+1] = Math.max(0, Math.min(255, c.g*255));
d[i+2] = Math.max(0, Math.min(255, c.b*255)); d[i+3] = 255;
}
ctx.putImageData(iD, 0, 0);
const t = new THREE.CanvasTexture(can);
t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
t.repeat.set(3000/w, 3000/h);
t.minFilter = THREE.NearestFilter; t.magFilter = THREE.NearestFilter;
return t;
}
function cGrd() {
const geo = new THREE.PlaneGeometry(3000, 3000);
const mat = new THREE.MeshStandardMaterial({map:cGT(), roughness:1.0});
const gnd = new THREE.Mesh(geo, mat);
gnd.rotation.x = -Math.PI/2; gnd.position.y = 0; gnd.receiveShadow = !0; S.add(gnd);
const aW = 500, aL = 320;
const aGeo = new THREE.PlaneGeometry(aW, aL);
const aMat = new THREE.MeshStandardMaterial({color:C.asph, roughness:1.0});
const asph = new THREE.Mesh(aGeo, aMat);
asph.rotation.x = -Math.PI/2; asph.position.y = 0.01;
asph.position.z = aL/2 - 60; asph.receiveShadow = !0; S.add(asph);
const lMat = new THREE.MeshBasicMaterial({color:C.aL});
const lGS = new THREE.PlaneGeometry(1.5, 20), lGSt = new THREE.PlaneGeometry(1.5, 25);
const cPR = (sZ, c, sX, sp, sl=!1, oX=0) => {
const geo = sl ? lGS : lGSt; const sA = Math.PI/5;
for (let i=0; i<c; i++) {
const xP = sX + i*sp + oX; const l = new THREE.Mesh(geo, lMat);
l.rotation.x = -Math.PI/2; if (sl) l.rotation.z = sA;
l.position.set(xP, 0.02, sZ); S.add(l);
}};
const nSW = 32, sXW = -240, sp = 15;
cPR(35, 20, -140, sp, !0); cPR(55, 20, -140, sp, !0, -5);
cPR(100, nSW, sXW, sp, !1); cPR(130, nSW, sXW, sp, !1);
cPR(190, nSW, sXW, sp, !1); cPR(220, nSW, sXW, sp, !1);
cRd();
}
function cRd() {
const {w:rW, l:rL, sZ:rSZ, sW} = R_CFG;
const rMat = new THREE.MeshStandardMaterial({color:0x0a0a15, roughness:0.9, metalness:0.1});
const rGeo = new THREE.PlaneGeometry(rW, rL);
const road = new THREE.Mesh(rGeo, rMat);
road.rotation.x = -Math.PI/2; road.position.set(0, 0.11, rSZ + rL/2);
road.receiveShadow = !0; S.add(road);
const lMat = new THREE.MeshBasicMaterial({color:0xffd700, polygonOffset:!0, polygonOffsetFactor:-1, polygonOffsetUnits:-1});
const cLGeo = new THREE.PlaneGeometry(1.5, 18); const dS = 25;
const nD = Math.floor(rL/dS);
for (let i=0; i<nD; i++) {
const zP = rSZ + (i*dS) + 10; const cL = new THREE.Mesh(cLGeo, lMat);
cL.rotation.x = -Math.PI/2; cL.position.set(0, 0.12, zP); S.add(cL);
}
const sLMat = new THREE.MeshBasicMaterial({color:0xffffff, polygonOffset:!0, polygonOffsetFactor:-1, polygonOffsetUnits:-1});
const cSLS = (st, end) => {
const sL = end - st; if (sL <= 0) return;
const sLGeo = new THREE.PlaneGeometry(1.2, sL);
const lL = new THREE.Mesh(sLGeo, sLMat);
lL.rotation.x = -Math.PI/2; lL.position.set(-rW/2 + 1, 0.12, st + sL/2); S.add(lL);
const rL = new THREE.Mesh(sLGeo, sLMat);
rL.rotation.x = -Math.PI/2; rL.position.set(rW/2 - 1, 0.12, st + sL/2); S.add(rL);
};
cSLS(rSZ, R_CFG.eZ);
const shMat = new THREE.MeshStandardMaterial({color:0x2a2035, roughness:1.0});
const cSS = (st, end) => {
const sL = end - st; if (sL <= 0) return;
const sGeo = new THREE.PlaneGeometry(sW, sL);
const lS = new THREE.Mesh(sGeo, shMat);
lS.rotation.x = -Math.PI/2; lS.position.set(-rW/2 - sW/2, 0.14, st + sL/2);
lS.receiveShadow = !0; S.add(lS);
const rS = new THREE.Mesh(sGeo, shMat);
rS.rotation.x = -Math.PI/2; rS.position.set(rW/2 + sW/2, 0.14, st + sL/2);
rS.receiveShadow = !0; S.add(rS);
};
cSS(rSZ, T_CFG.sZ); cSS(T_CFG.eZ, R_CFG.eZ);
const rLS = 100;
for (let z = rSZ+50; z < T_CFG.sZ-50; z += rLS) {
const rL1 = new THREE.PointLight(0xffd4a3, 0.8, 80);
rL1.position.set(-rW/2 - 15, 35, z); S.add(rL1);
const rL2 = new THREE.PointLight(0xffd4a3, 0.8, 80);
rL2.position.set(rW/2 + 15, 35, z); S.add(rL2);
}}
function cTun() {
const {sZ:tSZ, l:tL, w:tW, h:tH, wT} = T_CFG;
const wTexC = document.createElement('canvas'); wTexC.width = 32; wTexC.height = 128;
const wCtx = wTexC.getContext('2d');
wCtx.fillStyle = '#3a3a4a'; wCtx.fillRect(0, 0, 32, 128);
wCtx.fillStyle = '#2f2f3f'; wCtx.fillRect(0, 62, 32, 4);
const wTex = new THREE.CanvasTexture(wTexC);
wTex.wrapS = THREE.RepeatWrapping; wTex.wrapT = THREE.RepeatWrapping; wTex.repeat.set(tL/10, 4);
const tMat = new THREE.MeshStandardMaterial({color:C.tC, roughness:0.9, side:THREE.DoubleSide, map:wTex});
const shape = new THREE.Shape(); const oW = tW + wT*2; const oH = tH + wT;
shape.moveTo(-oW*1.5, 0); shape.lineTo(-oW/2, 0); shape.lineTo(-oW/2, oH*0.6);
shape.quadraticCurveTo(0, oH+15, oW/2, oH*0.6);
shape.lineTo(oW/2, 0); shape.lineTo(oW*1.5, 0); shape.closePath();
const hole = new THREE.Shape(); const sWH = tH*0.6;
hole.moveTo(-tW/2, 0.1); hole.lineTo(-tW/2, sWH);
hole.quadraticCurveTo(0, tH+5, tW/2, sWH);
hole.lineTo(tW/2, 0.1); hole.closePath(); shape.holes.push(hole);
const eSet = {steps:1, depth:tL, bevelEnabled:!1};
const geo = new THREE.ExtrudeGeometry(shape, eSet);
const tun = new THREE.Mesh(geo, tMat);
tun.position.set(0, 0.01, tSZ); tun.castShadow = !0; tun.receiveShadow = !0; S.add(tun);
const fMat = new THREE.MeshStandardMaterial({color:C.tF, roughness:1.0});
const fShape = new THREE.Shape(); const fW = oW + 6; const fOSWH = oH*0.6 + 3;
fShape.moveTo(-fW/2, 0); fShape.lineTo(-fW/2, fOSWH);
fShape.quadraticCurveTo(0, oH+20, fW/2, fOSWH);
fShape.lineTo(fW/2, 0); fShape.closePath(); fShape.holes.push(hole);
const fGeo = new THREE.ExtrudeGeometry(fShape, {steps:1, depth:5, bevelEnabled:!1});
const eF = new THREE.Mesh(fGeo, fMat); eF.position.set(0, 0.01, tSZ-5); eF.castShadow = !0; S.add(eF);
const exF = new THREE.Mesh(fGeo, fMat); exF.position.set(0, 0.01, tSZ+tL); exF.castShadow = !0; S.add(exF);
const dMat = new THREE.MeshStandardMaterial({color:C.tF, roughness:1.0}); dMat.color.multiplyScalar(0.7);
const pH = fOSWH+1, pW = 4, pD = 6; const pGeo = new THREE.BoxGeometry(pW, pH, pD);
const lP = new THREE.Mesh(pGeo, dMat);
lP.position.set(-fW/2-pW/2, pH/2+0.01, tSZ-pD/2+2.5); lP.castShadow = !0; S.add(lP);
const rP = new THREE.Mesh(pGeo, dMat);
rP.position.set(fW/2+pW/2, pH/2+0.01, tSZ-pD/2+2.5); rP.castShadow = !0; S.add(rP);
const lPEx = new THREE.Mesh(pGeo, dMat);
lPEx.position.set(-fW/2-pW/2, pH/2+0.01, tSZ+tL+pD/2-2.5); lPEx.castShadow = !0; S.add(lPEx);
const rPEx = new THREE.Mesh(pGeo, dMat);
rPEx.position.set(fW/2+pW/2, pH/2+0.01, tSZ+tL+pD/2-2.5); rPEx.castShadow = !0; S.add(rPEx);
const sH = 5, sW = tW-10;
const wTex = cTST("TUNNEL", 512, 128, 150);
const wSGeo = new THREE.BoxGeometry(sW, sH, 0.5);
const wSMat = new THREE.MeshBasicMaterial({map:wTex});
const wS = new THREE.Mesh(wSGeo, wSMat);
const aTY = tH+5; wS.position.set(0, aTY+sH/2+1.01, tSZ-4.8); S.add(wS);
const bHole = new THREE.Shape();
bHole.moveTo(-tW/2, 0.5); bHole.lineTo(-tW/2, sWH);
bHole.quadraticCurveTo(0, tH+5, tW/2, sWH);
bHole.lineTo(tW/2, 0.5); bHole.closePath();
const bGeo = new THREE.ShapeGeometry(bHole);
const bMat = new THREE.MeshBasicMaterial({color:0x000000, side:THREE.DoubleSide, fog:!1});
const bPlane = new THREE.Mesh(bGeo, bMat);
bPlane.position.set(0, 0, tSZ+tL-10); S.add(bPlane);
const lI = 1.2, lS = 50, lH = 22, lXO = tW/2*0.9;
const fHMat = new THREE.MeshStandardMaterial({color:0x222222, roughness:0.8});
const fLMat = new THREE.MeshBasicMaterial({color:C.tL});
const hGeo = new THREE.BoxGeometry(1.5, 1.5, 6), lGeo = new THREE.BoxGeometry(1.0, 1.0, 5);
for (let z = tSZ+30; z < tSZ+tL-30; z += lS) {
const lL = new THREE.PointLight(C.tL, lI, 60); lL.position.set(-lXO, lH, z); S.add(lL);
const lF = new THREE.Group(); const lHous = new THREE.Mesh(hGeo, fHMat);
const lLB = new THREE.Mesh(lGeo, fLMat); lLB.position.y = -0.25;
lF.add(lHous, lLB); lF.position.set(-lXO, lH, z); S.add(lF);
const rL = new THREE.PointLight(C.tL, lI, 60); rL.position.set(lXO, lH, z); S.add(rL);
const rF = new THREE.Group(); const rHous = new THREE.Mesh(hGeo, fHMat);
const rLB = new THREE.Mesh(lGeo, fLMat); rLB.position.y = -0.25;
rF.add(rHous, rLB); rF.position.set(lXO, lH, z); S.add(rF);
}
cBsh(-85, tSZ-20); cBsh(-70, tSZ-45); cBsh(-95, tSZ-55); cBsh(-105, tSZ-30);
cBsh(85, tSZ-20); cBsh(75, tSZ-35); cBsh(90, tSZ-50); cBsh(105, tSZ-30);
}
function cPL() {
const pMat = new THREE.MeshStandardMaterial({color:C.pM});
const lMat = new THREE.MeshBasicMaterial({color:C.pG}); const pH = 40;
const createPL = (x, z) => {
const pGeo = new THREE.CylinderGeometry(0.8, 1.2, pH, 6); pGeo.translate(0, pH/2, 0);
const pole = new THREE.Mesh(pGeo, pMat); pole.position.set(x, 0, z); pole.castShadow = !0; S.add(pole);
const fGeo = new THREE.BoxGeometry(8, 2, 6); const fix = new THREE.Mesh(fGeo, pMat);
fix.position.set(x, pH+1, z); fix.castShadow = !0; S.add(fix);
const bGeo = new THREE.BoxGeometry(6, 0.5, 4); const bulb = new THREE.Mesh(bGeo, lMat);
bulb.position.set(x, pH, z); S.add(bulb);
const light = new THREE.SpotLight(C.pG, 2.0, 120, Math.PI/3, 0.5);
light.position.set(x, pH-1, z); light.target.position.set(x, 0, z);
light.castShadow = !0; S.add(light); S.add(light.target);
};
createPL(-150, 75); createPL(0, 75); createPL(150, 75);
createPL(-150, 160); createPL(0, 160); createPL(150, 160);
createPL(-80, 250); createPL(80, 250);
}
function aCE(cX, y, z) {
const dPM = new THREE.MeshStandardMaterial({color:0x444444, roughness:0.6});
const dPT = 0.5, dPS = 4, dPAW = 1.5;
const hG = new THREE.BoxGeometry(dPS, dPAW, dPT);
const hP = new THREE.Mesh(hG, dPM); hP.castShadow = !0;
const vG = new THREE.BoxGeometry(dPAW, dPS, dPT);
const vP = new THREE.Mesh(vG, dPM); vP.castShadow = !0;
const dPG = new THREE.Group(); dPG.add(hP); dPG.add(vP);
dPG.position.set(cX-7, 8, z); S.add(dPG);
const bG = new THREE.Group(); const bR = 1.0, bT = 0.4, bS = 2.5;
const cB = (x, y, c, l, tR=0) => {
const geo = new THREE.CylinderGeometry(bR, bR, bT, 16); geo.rotateX(Math.PI/2);
const fT = cTTS(l, '#ffffff', 30); fT.rotation = tR; fT.center.set(0.5, 0.5);
const fM = new THREE.MeshStandardMaterial({color:c, map:fT, roughness:0.3});
const sM = new THREE.MeshStandardMaterial({color:c, roughness:0.3});
const btn = new THREE.Mesh(geo, [sM, fM, sM]);
btn.position.set(x, y, 0); btn.castShadow = !0; bG.add(btn);
};
cB(0, -bS, 0x2ecc71, 'A', Math.PI/2); cB(-bS, 0, 0xe74c3c, 'B', Math.PI/2);
cB(0, bS, 0xf1c40f, 'Y', Math.PI/2); cB(bS, 0, 0x3498db, 'X', Math.PI/2);
bG.position.set(cX+7, 8, z); S.add(bG);
}
function cBui() {
const bH = 25, bD = 30, zP = 0;
const cMat = new THREE.MeshStandardMaterial({color:C.stc});
const tMat = new THREE.MeshStandardMaterial({color:C.stcD});
const sMat = new THREE.MeshStandardMaterial({color:C.brk});
const cW = 35, cH = bH+3;
const cGeo = new THREE.BoxGeometry(cW, cH, bD); cGeo.translate(0, cH/2, 0);
const cB = new THREE.Mesh(cGeo, cMat);
cB.position.set(0, 0, zP); cB.castShadow = !0; cB.receiveShadow = !0; S.add(cB);
const rTCG = new THREE.BoxGeometry(cW+4, 4, bD+2);
const rTC = new THREE.Mesh(rTCG, tMat);
rTC.position.set(0, bH+3, zP); rTC.castShadow = !0; S.add(rTC);
const aG = new THREE.BoxGeometry(cW-10, 6, bD+1);
const arch = new THREE.Mesh(aG, cMat);
arch.position.set(0, bH+7, zP); arch.castShadow = !0; S.add(arch);
const sW = 32; const sGeo = new THREE.BoxGeometry(sW, bH, bD); sGeo.translate(0, bH/2, 0);
const xPL = -(cW/2 + sW/2), xPR = cW/2 + sW/2, xPFR = xPR + sW, xPEFR = xPFR + sW;
const lB = new THREE.Mesh(sGeo, sMat); lB.position.set(xPL, 0, zP); lB.castShadow = !0; lB.receiveShadow = !0; S.add(lB);
const rB = new THREE.Mesh(sGeo, sMat); rB.position.set(xPR, 0, zP); rB.castShadow = !0; rB.receiveShadow = !0; S.add(rB);
const fRB = new THREE.Mesh(sGeo, sMat); fRB.position.set(xPFR, 0, zP); fRB.castShadow = !0; fRB.receiveShadow = !0; S.add(fRB);
const eFRB = new THREE.Mesh(sGeo, sMat); eFRB.position.set(xPEFR, 0, zP); eFRB.castShadow = !0; eFRB.receiveShadow = !0; S.add(eFRB);
const rTSG = new THREE.BoxGeometry(sW+2, 3, bD+2);
const rTL = new THREE.Mesh(rTSG, tMat); rTL.position.set(xPL, bH+0.5, zP); rTL.castShadow = !0; S.add(rTL);
const rTR = new THREE.Mesh(rTSG, tMat); rTR.position.set(xPR, bH+0.5, zP); rTR.castShadow = !0; S.add(rTR);
const rTFR = new THREE.Mesh(rTSG, tMat); rTFR.position.set(xPFR, bH+0.5, zP); rTFR.castShadow = !0; S.add(rTFR);
const rTEFR = new THREE.Mesh(rTSG, tMat); rTEFR.position.set(xPEFR, bH+0.5, zP); rTEFR.castShadow = !0; S.add(rTEFR);
const wZ = zP + bD/2 + 0.1, wY = 8, iZ = 19, iZ2 = 20.5;
cWin(0, wY, wZ, 28, 12, C.wGB, 1.5);
aShr(-10, 8, iZ, 0x457b9d); aShr(10, 8, iZ, 0xe63946); aShr(0, 7.5, iZ2, 0x1d3557);
cWin(xPL, wY, wZ, 26, 12, C.wGB, 1.2);
aPpr(xPL-7, 8, iZ); aPpr(xPL+7, 8.5, iZ); aPpr(xPL, 7, iZ);
cWin(xPR, wY, wZ, 26, 12, C.wGD, 0.8);
aPpr(xPR-7, 8.5, iZ); aPpr(xPR+7, 8, iZ); aPpr(xPR+1, 7.5, iZ);
cWin(xPFR, wY, wZ, 26, 12, C.wGB, 1.2);
aTB(xPFR+5, 8.5, iZ, 8, 5.5, 0xffe066, 'bottom-right');
aTB(xPFR-6, 7.5, iZ2, 6, 4, 0x48bfe3, 'bottom-left');
aTB(xPFR-1, 11.5, iZ, 4.5, 3, 0xfb6f92, 'top-left');
cWin(xPEFR, wY, wZ, 26, 12, C.wGD, 1.0);
aCE(xPEFR, wY, iZ);
const sZ = wZ + 0.5;
cSig("RESUME", C.sR, xPL, 20, sZ, 'resume', 50);
cSig("T-SHIRTS", C.sT, 0, 21, sZ, 'tshirts', 50);
cSig("PROJECTS", C.sP, xPR, 20, sZ, 'projects', 50);
cSig("ASK JOHN", C.sAJ, xPFR, 20, sZ, 'askjohn', 50);
cSig("MINI GAMES", C.sMG, xPEFR, 20, sZ, 'minigames', 45);
const aY = 15;
cAwn(xPL, aY, cST('#991b1b', '#fecaca'));
cAwn(xPR, aY, cST('#065f46', '#047857'));
cAwn(xPFR, aY, cST('#ffA700', '#333333'));
cAwn(xPEFR, aY, cST('#6a0dad', '#4b0082'));
}
function cWin(x, y, z, w, h, col, i) {
const wM = new THREE.MeshBasicMaterial({color:col, transparent:!0, opacity:0.95});
const wG = new THREE.PlaneGeometry(w, h);
const wMesh = new THREE.Mesh(wG, wM); wMesh.position.set(x, y, z); S.add(wMesh);
const sL = new THREE.PointLight(col, i, 50);
sL.position.set(x, y+5, z-15); sL.castShadow = !0; S.add(sL);
const siL = new THREE.SpotLight(col, i*0.3, 40, Math.PI/3, 0.5);
siL.position.set(x, y-5, z+5); siL.target.position.set(x, 0, z+25);
S.add(siL); S.add(siL.target);
}
function aShr(x, y, z, col) {
const m = new THREE.MeshStandardMaterial({color:col, depthWrite:!0, depthTest:!0, polygonOffset:!0, polygonOffsetFactor:-1, polygonOffsetUnits:-1});
const sG = new THREE.Group();
const bG = new THREE.BoxGeometry(5, 6, 2); bG.rotateY(Math.PI);
const b = new THREE.Mesh(bG, m); b.position.z = 0.3; b.renderOrder = 1; sG.add(b);
const slG = new THREE.BoxGeometry(2.5, 2.5, 1.8); slG.rotateY(Math.PI);
const sL = new THREE.Mesh(slG, m); sL.position.set(-3.5, 1.5, 0.2); sL.rotation.z = Math.PI/6; sL.renderOrder = 1; sG.add(sL);
const sR = new THREE.Mesh(slG, m); sR.position.set(3.5, 1.5, 0.2); sR.rotation.z = -Math.PI/6; sR.renderOrder = 1; sG.add(sR);
sG.position.set(x, y, z); sG.castShadow = !0; S.add(sG);
}
function aPpr(x, y, z) {
const m = new THREE.MeshStandardMaterial({color:0xfafafa, roughness:0.8});
const pG = new THREE.BoxGeometry(4, 5.5, 0.2); pG.rotateY(Math.PI);
const p = new THREE.Mesh(pG, m); p.position.set(x, y, z);
p.rotation.z = (Math.random()-0.5)*0.3; p.rotation.x = Math.PI/12 + (Math.random()-0.5)*0.2;
p.castShadow = !0; S.add(p);
}
function aTB(x, y, z, w, h, col, pS='bottom-left') {
const m = new THREE.MeshStandardMaterial({color:col, roughness:0.6, side:THREE.DoubleSide, depthWrite:!0, depthTest:!0, polygonOffset:!0, polygonOffsetFactor:-1, polygonOffsetUnits:-1});
const shp = new THREE.Shape(); const rX = w/2, rY = h/2;
shp.absellipse(0, 0, rX, rY, 0, Math.PI*2, !1, 0);
const eS = {steps:1, depth:0.5, bevelEnabled:!0, bevelThickness:0.1, bevelSize:0.1, bevelSegments:3};
const geo = new THREE.ExtrudeGeometry(shp, eS); geo.rotateY(Math.PI);
const bub = new THREE.Mesh(geo, m); bub.renderOrder = 1;
const pShp = new THREE.Shape(); const pSz = Math.min(w, h)*0.3;
let p1x, p1y, p2x, p2y, p3x, p3y;
switch (pS) {
case 'top-left': p1x=-rX*0.3; p1y=rY*0.95; p2x=p1x-pSz*0.5; p2y=p1y+pSz; p3x=p1x+pSz*0.3; p3y=rY*0.95; break;
case 'top-right': p1x=rX*0.3; p1y=rY*0.95; p2x=p1x+pSz*0.5; p2y=p1y+pSz; p3x=p1x-pSz*0.3; p3y=rY*0.95; break;
case 'bottom-right': p1x=rX*0.4; p1y=-rY*0.95; p2x=p1x+pSz*0.6; p2y=p1y-pSz; p3x=p1x-pSz*0.2; p3y=-rY*0.95; break;
case 'bottom-left': default: p1x=-rX*0.4; p1y=-rY*0.95; p2x=p1x-pSz*0.6; p2y=p1y-pSz; p3x=p1x+pSz*0.2; p3y=-rY*0.95; break;
}
pShp.moveTo(p1x, p1y); pShp.lineTo(p2x, p2y); pShp.lineTo(p3x, p3y); pShp.closePath();
const pGeo = new THREE.ExtrudeGeometry(pShp, eS); pGeo.rotateY(Math.PI);
const pM = new THREE.Mesh(pGeo, m); pM.renderOrder = 1;
const grp = new THREE.Group(); grp.add(bub); grp.add(pM);
grp.position.set(x, y, z + eS.depth/2); grp.castShadow = !0; S.add(grp);
}
function cAwn(xP, yP, tex) {
tex.repeat.set(6, 1);
const m = new THREE.MeshStandardMaterial({map:tex});
const g = new THREE.BoxGeometry(32, 1.5, 8);
const awn = new THREE.Mesh(g, m);
awn.position.set(xP, yP, 18); awn.rotation.x = Math.PI/4; awn.castShadow = !0;
S.add(awn);
}
function cSig(txt, col, xP, yP, zP, id, fS=45) {
const tex = cTT(txt, new THREE.Color(col).getStyle(), '#ffffff', 256, 64, fS);
const m = new THREE.MeshBasicMaterial({map:tex});
const g = new THREE.BoxGeometry(26, 5, 1.5);
const sign = new THREE.Mesh(g, m);
sign.position.set(xP, yP, zP); sign.name = id;
S.add(sign); cO.push(sign);
}
function cBB() {
const pH=70, tPH=pH+30, bY=pH+15, bZ=-30, rA=35*Math.PI/180;
const bG = new THREE.Group(); bG.position.set(0, 0, bZ); bG.rotation.y = rA;
const pG = new THREE.CylinderGeometry(2.5, 2.5, tPH, 8); pG.translate(0, tPH/2, 0);
const pM = new THREE.MeshStandardMaterial({color:C.mD});
const pole = new THREE.Mesh(pG, pM); pole.position.set(0, 0, 0); pole.castShadow = !0; bG.add(pole);
const bW=80, bH=35;
const tex = cTT("JOHN GRESH", new THREE.Color(C.bG).getStyle(), new THREE.Color(C.bT).getStyle(), 512, 256, 70);
tex.generateMipmaps = !1;
const bM = new THREE.MeshBasicMaterial({map:tex, side:THREE.FrontSide});
const bGeo = new THREE.BoxGeometry(bW, bH, 0.5);
const board = new THREE.Mesh(bGeo, bM); board.position.set(0, bY, 3); board.renderOrder = 1; bG.add(board);
const sM = new THREE.MeshStandardMaterial({color:C.mD});
const sG = new THREE.BoxGeometry(bW+6, bH+6, 1);
const struc = new THREE.Mesh(sG, sM);
struc.position.set(0, bY, 0); struc.castShadow = !0; struc.renderOrder = 0; bG.add(struc);
const lW=bW+6, lD=4, lH=1; const lG = new THREE.BoxGeometry(lW, lH, lD);
const lB = new THREE.Mesh(lG, sM);
const sBY = bY - (bH+6)/2;
lB.position.set(0, sBY-lH/2, -0.5-lD/2); lB.castShadow = !0; bG.add(lB);
const rH=4, rT=0.4; const tRG = new THREE.BoxGeometry(lW, rT, rT);
const tRB = new THREE.Mesh(tRG, sM);
const lTY = sBY, lBZ = -0.5-lD;
tRB.position.set(0, lTY+rH-rT/2, lBZ+rT/2); tRB.castShadow = !0; bG.add(tRB);
const postG = new THREE.BoxGeometry(rT, rH, rT); const nP = 7;
for (let i=0; i<nP; i++) {
const p = new THREE.Mesh(postG, sM);
const xP = -lW/2+rT/2 + i*((lW-rT)/(nP-1));
p.position.set(xP, lTY+rH/2, lBZ+rT/2); p.castShadow = !0; bG.add(p);
}
const lF = new THREE.Mesh(lG, sM);
lF.position.set(0, sBY-lH/2, 0.5+lD/2+2.5); lF.castShadow = !0; bG.add(lF);
const tRF = new THREE.Mesh(tRG, sM); const lFZ = 0.5+lD+2.5;
tRF.position.set(0, lTY+rH-rT/2, lFZ-rT/2); tRF.castShadow = !0; bG.add(tRF);
for (let i=0; i<nP; i++) {
const p = new THREE.Mesh(postG, sM);
const xP = -lW/2+rT/2 + i*((lW-rT)/(nP-1));
p.position.set(xP, lTY+rH/2, lFZ-rT/2); p.castShadow = !0; bG.add(p);
}
const lFM = new THREE.MeshBasicMaterial({color:0x333333});
const lBM = new THREE.MeshBasicMaterial({color:C.bG});
for(let i=-1.5; i<=1.5; i++){
const fX=i*25, fY=bY+bH/2+3; const fG = new THREE.Group(); fG.position.set(fX, fY, 5);
const hG = new THREE.BoxGeometry(5, 2, 2); const head = new THREE.Mesh(hG, lFM);
head.position.set(0, 0, 0); fG.add(head);
const bG = new THREE.BoxGeometry(4, 0.8, 0.8); const bulb = new THREE.Mesh(bG, lBM);
bulb.position.set(0, -0.8, 0.5); fG.add(bulb);
const aG = new THREE.BoxGeometry(1, 4, 1); const arm = new THREE.Mesh(aG, lFM);
arm.position.set(0, -2, -3); fG.add(arm); bG.add(fG);
const sL = new THREE.SpotLight(0xfff8e1, 2.5, 120, Math.PI/8, 0.5);
sL.position.set(fX, fY, 5); sL.target = board; bG.add(sL);
}
S.add(bG);
}
function cBsh(x, z, scale=1.0) {
const fM = new THREE.MeshStandardMaterial({color:C.tD, roughness:1.0}); fM.color.multiplyScalar(0.85);
const bG = new THREE.Group(); const nL = Math.floor(Math.random()*3) + 4;
for (let i=0; i<nL; i++) {
const lS = (Math.random()*5 + 5)*scale; const lG = new THREE.BoxGeometry(lS, lS, lS);
const l = new THREE.Mesh(lG, fM);
const oX=(Math.random()-0.5)*6*scale, oY=lS/2-2*scale, oZ=(Math.random()-0.5)*6*scale;
l.position.set(oX, oY, oZ); l.rotation.y = Math.random()*Math.PI; l.castShadow = !0; bG.add(l);
}
bG.position.set(x, 0, z); S.add(bG);
}
function cTre() {
const tM = new THREE.MeshStandardMaterial({color:C.tT, roughness:1.0});
const fM = new THREE.MeshStandardMaterial({color:C.tD, roughness:1.0});
const dFM = new THREE.MeshStandardMaterial({color:C.tD, roughness:1.0, fog:!0}); dFM.color.multiplyScalar(0.5);
const {w:rW, sZ:rSZ, eZ:rEZ} = R_CFG; const rC = 25;
const {sZ:tSZ, eZ:tEZ, cW:tCW} = T_CFG;
const iIRC = (x, z) => (z >= rSZ && z <= rEZ) ? Math.abs(x) < (rW/2 + rC) : !1;
const iOPL = (x, z) => {
const aW=500, aL=320, aCZ=aL/2-60;
return Math.abs(x) < aW/2 && z > (aCZ-aL/2) && z < (aCZ+aL/2);
};
const iITC = (x, z) => {
const eZ=tSZ-50, exZ=tEZ+50;
return (z >= eZ && z <= exZ) ? Math.abs(x) < tCW/2 : !1;
};
const cT = (x, z, scale=1.0, isD=!1, y=0) => {
if (y === 0 && (iITC(x, z) || iOPL(x, z) || (!isD && iIRC(x, z)))) return;
const tH=(Math.random()*10+15)*scale, tR=(Math.random()*1.5+1.5)*scale;
const cFM = isD ? dFM : fM;
if (!isD) {
const tG = new THREE.CylinderGeometry(tR*0.8, tR, tH, 6); tG.translate(0, tH/2, 0);
const t = new THREE.Mesh(tG, tM); t.position.set(x, y, z); t.castShadow = !0; S.add(t);
}
const fL=3; let cY = y + (isD ? 0 : tH*0.8); let bW = (Math.random()*20+25)*scale;
for (let i=0; i<fL; i++) {
const lH=(Math.random()*15+12)*scale, lW=bW*(1-i*0.25);
const fG = new THREE.BoxGeometry(lW, lH, lW); const f = new THREE.Mesh(fG, cFM);
const oX=(Math.random()-0.5)*6*scale, oZ=(Math.random()-0.5)*6*scale;
f.position.set(x+oX, cY+lH/2, z+oZ); f.rotation.y = Math.random()*Math.PI;
if (!isD) { f.castShadow = !0; f.receiveShadow = !0; }
S.add(f); cY += lH*0.7;
}};
const bX=450, bZ=280, sp=45;
for (let i=-bX; i<=bX; i+=sp) {
cT(i+Math.random()*15, -60-Math.random()*15);
cT(i+Math.random()*20, -100-Math.random()*30);
cT(i+Math.random()*25, -150-Math.random()*50);
}
for (let i=-bX; i<=bX; i+=sp) {
cT(i+Math.random()*15, bZ+Math.random()*15);
cT(i+Math.random()*20, bZ+40+Math.random()*30);
}
for (let i=-150; i<=bZ+40; i+=sp) {
cT(-bX+Math.random()*15, i); cT(-bX-40+Math.random()*20, i);
}
for (let i=-150; i<=bZ+40; i+=sp) {
cT(bX+Math.random()*15, i); cT(bX+40+Math.random()*20, i);
}
for (let i=0; i<25; i++) {
const x=-280+(Math.random()-0.5)*120, z=150+(Math.random()-0.5)*150;
cT(x, z, 1.0+Math.random()*0.2);
}
const rSS=60;
for (let z=rSZ+50; z<rEZ-100; z+=rSS) {
const lX = -(rW/2+rC+Math.random()*15+20); cT(lX, z+Math.random()*20-10);
const rX = (rW/2+rC+Math.random()*15+20); cT(rX, z+Math.random()*20-10);
}
const bD=750, bgS=12, bgL=4, bgSc=2.5; const aS = Math.PI/180*bgS;
for (let a=0; a<Math.PI*2; a+=aS) {
for (let l=0; l<bgL; l++) {
const lO=l*50; const d=bD-lO+(Math.random()-0.5)*60;
const aN=(Math.random()-0.5)*aS*0.8; const cA=a+aN;
const x=Math.cos(cA)*d, z=Math.sin(cA)*d;
const sc=bgSc+(Math.random()*1.0);
cT(x, z, sc, !0);
}}}
function cSta() {
const g=new THREE.BufferGeometry(); const v=[]; const dR=4900;
for (let i=0; i<400; i++) {
const x=Math.random()*dR-dR/2, y=Math.random()*200+150, z=Math.random()*dR-dR/2;
if (Math.sqrt(x*x+z*z) > 150) v.push(x, y, z);
}
g.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
const m=new THREE.PointsMaterial({color:0xffffff, size:3, sizeAttenuation:!1, transparent:!0, opacity:0.6, fog:!1});
const stars=new THREE.Points(g, m); S.add(stars);
}

function sEL() {
window.addEventListener('resize', oWR, !1);
document.addEventListener('keydown', oKD, !1);
document.addEventListener('keyup', oKU, !1);
R.domElement.addEventListener('mousedown', oDDS, !1);
document.addEventListener('mousemove', oDDM, !1);
document.addEventListener('mouseup', oDDE, !1);
R.domElement.addEventListener('click', oMC, !1);
document.addEventListener('touchstart', oTS, {passive:!1});
document.addEventListener('touchmove', oTM, {passive:!1});
document.addEventListener('touchend', oTE, !1);
document.addEventListener('touchcancel', oTE, !1);
document.querySelectorAll('.cb').forEach(b => b.addEventListener('click', hO, !1));
document.querySelectorAll('.so').forEach(o => {
o.addEventListener('click', function(e) {
if (document.getElementById('pwdm').style.display === 'flex') return;
if (e.target === this) hO();
}, !1);
});
const jb = document.getElementById('jb');
if (jb) {
jb.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); K[' '] = !0; jb.classList.add('active'); });
jb.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); K[' '] = !1; jb.classList.remove('active'); });
jb.addEventListener('mousedown', (e) => e.preventDefault());
}}

function oWR() {
const w=window.innerWidth, h=window.innerHeight;
const dpr=window.devicePixelRatio || 1; let eDPR;
if (isPad()) eDPR = 1.0; else if (isMob()) eDPR = Math.min(1.5, dpr); else eDPR = dpr;
R.setPixelRatio(eDPR); Cam.aspect = w/h; Cam.updateProjectionMatrix();
R.setSize(w, h); Comp.setSize(w, h);
const cDPR = R.getPixelRatio();
if (PP && PP.uniforms.resolution) {
PP.uniforms.resolution.value.set(w*cDPR, h*cDPR);
PP.uniforms.pixelSize.value = gPS();
}
if (pG && !iSA && document.getElementById('mgo').style.display !== 'none') setTimeout(() => pG.rC(), 100);
iJ();
if (iSA) {
document.getElementById('cc').style.display = 'block';
if (isMob()) {
document.getElementById('mctrl').style.display = 'flex';
document.getElementById('i').style.display = 'none';
} else {
document.getElementById('mctrl').style.display = 'none';
document.getElementById('i').style.display = 'block';
}}}

function oKD(e) {
if (document.activeElement.id === 'ci' || document.activeElement.id === 'pwdi') return;
if (e.key === 'Escape' && document.getElementById('pwdm').style.display === 'flex') {
document.getElementById('pwdm').style.display = 'none';
if (document.getElementById('ajo').style.display === 'flex') document.getElementById('ci').focus();
return;
}
if (e.key === 'Escape' && !iSA) { hO(); return; }
if (pG && pG.Run) return;
if (!iSA) return;
if (K.hasOwnProperty(e.key.toLowerCase())) { K[e.key.toLowerCase()] = !0; e.preventDefault(); }
if(e.key === ' '){ K[' '] = !0; e.preventDefault(); }
}
function oKU(e) {
if (K.hasOwnProperty(e.key.toLowerCase())) K[e.key.toLowerCase()] = !1;
if(e.key === ' ') K[' '] = !1;
}
function oDDS(e) {
if (!iSA || isMob()) return;
iD = !0; dS.x = e.clientX; dS.y = e.clientY; document.body.style.cursor = 'grabbing';
}
function oDDM(e) {
if (!iD || !iSA || isMob()) return;
const dX = e.clientX - dS.x, dY = e.clientY - dS.y;
hR(dX, dY, 0.003);
dS.x = e.clientX; dS.y = e.clientY;
}
function oDDE() {
if (isMob()) return;
iD = !1; if (iSA) document.body.style.cursor = 'grab';
}

function oTS(e) {
if ((!iSA && document.getElementById('pwdm').style.display !== 'flex') || !isMob()) return;
const jZ = document.getElementById('jz'), aB = document.getElementById('ab');
if (e.changedTouches.length > 0) {
const t = e.changedTouches[0], tgt = t.target;
if (!(jZ && jZ.contains(tgt)) && !(aB && aB.contains(tgt))) {
dS.tapX = t.clientX; dS.tapY = t.clientY; dS.tapTime = Date.now();
}}
if (lTI !== null) return;
for (const t of e.changedTouches) {
const tgt = t.target;
if ((jZ && jZ.contains(tgt)) || (aB && aB.contains(tgt))) continue;
if (iSA) e.preventDefault();
iD = !0; lTI = t.identifier;
dS.x = t.clientX; dS.y = t.clientY;
break;
}}

function oTM(e) {
if ((!iSA && document.getElementById('pwdm').style.display !== 'flex') || !isMob()) return;
if (iD && lTI !== null) {
for (const t of e.touches) {
if (t.identifier === lTI) {
if (iSA) e.preventDefault();
const dX = t.clientX - dS.x, dY = t.clientY - dS.y;
hR(dX, dY, 0.006);
dS.x = t.clientX; dS.y = t.clientY;
break;
}}}}

function oTE(e) {
if (!isMob()) return;
if (e.changedTouches.length > 0 && iSA) {
const t = e.changedTouches[0];
const tDur = Date.now() - (dS.tapTime || 0);
const tDist = Math.sqrt(Math.pow(t.clientX - (dS.tapX || 0), 2) + Math.pow(t.clientY - (dS.tapY || 0), 2));
if (tDur < 300 && tDist < 10) {
if (e.target.tagName.toLowerCase() === 'canvas' || t.identifier === lTI) {
M.x = (t.clientX / window.innerWidth)*2 - 1;
M.y = -(t.clientY / window.innerHeight)*2 + 1;
Ray.setFromCamera(M, Cam);
const ints = Ray.intersectObjects(cO);
if (ints.length > 0) {
const obj = ints[0].object;
switch(obj.name) {
case 'resume': sO('ro'); break;
case 'tshirts': sO('to'); break;
case 'projects': sO('po'); break;
case 'askjohn': sO('ajo'); break;
case 'minigames': sO('mgo'); break;
}}}}}}
for (const t of e.changedTouches) {
if (t.identifier === lTI) { iD = !1; lTI = null; break; }
}}

function hR(dX, dY, s) {
cR.rotation.y -= dX*s; cP.rotation.x -= dY*s;
const mP = Math.PI/2.5;
cP.rotation.x = Math.max(-mP, Math.min(mP, cP.rotation.x));
}
function oMC(e) {
if (!iSA) return;
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) return;
e.preventDefault();
M.x = (e.clientX / window.innerWidth)*2 - 1;
M.y = -(e.clientY / window.innerHeight)*2 + 1;
Ray.setFromCamera(M, Cam);
const ints = Ray.intersectObjects(cO);
if (ints.length > 0) {
const obj = ints[0].object;
switch(obj.name) {
case 'resume': sO('ro'); break;
case 'tshirts': sO('to'); break;
case 'projects': sO('po'); break;
case 'askjohn': sO('ajo'); break;
case 'minigames': sO('mgo'); break;
}}}
function uPM(d) {
const aS = 35.0*d;
const fwd = new THREE.Vector3(), right = new THREE.Vector3();
cR.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
right.crossVectors(cR.up, fwd).normalize();
if (K.w || K.ArrowUp) cR.position.addScaledVector(fwd, -aS);
if (K.s || K.ArrowDown) cR.position.addScaledVector(fwd, aS);
if (K.a || K.ArrowLeft) cR.position.addScaledVector(right, -aS);
if (K.d || K.ArrowRight) cR.position.addScaledVector(right, aS);
if (Math.abs(JSI.x) > 0.05 || Math.abs(JSI.y) > 0.05) {
cR.position.addScaledVector(fwd, -JSI.y*aS);
cR.position.addScaledVector(right, JSI.x*aS);
}
if (K[' '] && !iJmp) { iJmp = !0; yV = jF; }
if (iJmp) {
yV += Gv*d; cR.position.y += yV*d;
if (cR.position.y <= pHt) { cR.position.y = pHt; iJmp = !1; yV = 0; }
}}
function A() {
requestAnimationFrame(A);
const d = Clk.getDelta(), t = Clk.getElapsedTime();
if (iSA) { uPM(d); uC(d, t); }
uFw(d);
if (iSA || FW.length > 0) Comp.render();
}

const AC = "ROSEBUD";
let iPAG = !1;

function uPUS() {
const cb = document.getElementById('pmc');
const ajc = document.getElementById('ajc');
if (!cb || !ajc) return;
if (cb.checked && iPAG) ajc.classList.add('pa');
else ajc.classList.remove('pa');
}

function iPM() {
const tg = document.getElementById('jot'), cb = document.getElementById('pmc');
const mdl = document.getElementById('pwdm'), sB = document.getElementById('spb');
const cB = document.getElementById('cpb'), pI = document.getElementById('pwdi');
const eM = document.getElementById('pwde');
if (!tg || !cb || !mdl) return;

tg.addEventListener('click', (e) => {
e.preventDefault();
if (iPAG) { cb.checked = !cb.checked; uPUS(); return; }
if (cb.checked) { cb.checked = !1; uPUS(); }
else sPM();
});

cB.addEventListener('click', hPM);
sB.addEventListener('click', vP);
pI.addEventListener('keypress', (e) => { if (e.key === 'Enter') vP(); });

function sPM() {
mdl.style.display = 'flex'; pI.value = ''; eM.style.display = 'none'; pI.focus();
}
function hPM() {
mdl.style.display = 'none';
if (document.getElementById('ajo').style.display === 'flex') document.getElementById('ci').focus();
}
function vP() {
const eP = pI.value.trim().toUpperCase();
if (eP === AC) {
iPAG = !0; cb.checked = !0; uPUS(); hPM();
} else {
eM.style.display = 'block'; pI.value = ''; pI.focus();
document.querySelector('.mc').animate([
{transform: 'translateX(0)'}, {transform: 'translateX(-10px)'}, {transform: 'translateX(10px)'}, {transform: 'translateX(0)'}
], {duration: 300, iterations: 1});
}}
uPUS();
}

const W_URL = "https://serverbackend.johngresh-usa.workers.dev/chat";
let cH = [], iCI = !1;

function iChat() {
if (iCI) return;
const sB = document.getElementById('sb'), cI = document.getElementById('ci');
const uTB = document.getElementById('utb');
if (!sB || !cI) return;
iCI = !0;
sB.addEventListener('click', () => hSM(!1));
cI.addEventListener('keypress', (e) => { if (e.key === 'Enter') hSM(!1); });
if (uTB) uTB.addEventListener('click', () => hSM(!0));
aMTC("Hello! I'm John's AI assistant. Feel free to ask me about his experience, skills, or projects.", 'bot');
}

async function rUTS() {
const tST = 180000, sT = Date.now();
const delay = ms => new Promise(r => setTimeout(r, ms));
const aM = async (m, ms) => { aSM(m); await delay(ms); };

await aM("Initializing UltraThink Protocol v3.0...", 3000);
await aM("Allocating 5 parallel cognitive instances (Premium Model)...", 2500);
for (let i=1; i<=5; i++) await aM(`Instance ${i}/5 [Booting]... Status: Loading Core Knowledge...`, Math.random()*1500 + 1500);
await aM("All instances synchronized. [Status: Ready]", 3000);
await aM("--- PHASE 1: DIVERGENT ANALYSIS ---", 1000);
await aM("Broad spectrum analysis initiated (Temp: High)...", 2000);
await delay(20000);
await aM("Phase 1 Complete. Collating initial thought vectors...", 3000);

await aM("--- PHASE 2: KNOWLEDGE SYNTHESIS ---", 1000);
await aM("Activating Synthesizer Module...", 2500);
await aM("Analyzing 5 distinct perspectives...", 1500);
await delay(30000);
await aM("Generating Shared Knowledge Base (SKB)...", 4000);
await aM("[SKB Generated]", 2000);

await aM("--- PHASE 3: ITERATIVE REFINEMENT ---", 1000);
await aM("Distributing SKB to 5 refinement instances (Temp: Med)...", 3000);
const tI = 8;
for (let i=1; i<=tI; i++) {
const iST = Date.now();
const tE = iST - sT;
const tR = tST - tE - 20000;
if (tR <= 0 && i < tI) {
await aM(`[WARNING]: Time limit approaching. Accelerating refinement...`, 1000); break;
}
const tID = Math.max(8000, tR / (tI - i + 1));
await aM(`-- Iteration ${i}/${tI} --`, 1000);
await aM(`[P3.${i}.1] Instances analyzing SKB and refining output...`, 500);
await delay(tID * 0.7);
await aM(`[P3.${i}.2] Cross-instance validation and data sharing...`, 500);
await delay(tID * 0.2);
await aM(`Iteration ${i} complete. Confidence score improved.`, 1000);
}

await aM("--- PHASE 4: FINALIZATION ---", 1000);
await aM("Activating Finalizer Module...", 2500);
await aM("Consolidating refined outputs...", 1500);
await delay(10000);
await aM("Running coherence and persona alignment checks...", 3000);
await aM("UltraThink Protocol Complete. Preparing transmission...", 1000);
}

function aSM(m) {
const cM = document.getElementById('cm'), cW = document.getElementById('cw');
if (!cM || !cW) return;
const mE = document.createElement('div');
mE.classList.add('sm'); mE.textContent = "> " + m;
cM.appendChild(mE);
cW.scrollTo({top: cW.scrollHeight, behavior: 'auto'});
}

async function hSM(isUT = !1) {
const cI = document.getElementById('ci');
const msg = cI.value.trim();
const pC = document.getElementById('pmc');
const useP = (pC && pC.checked && iPAG);
if (isUT && !useP) return;
if (msg === '') return;

aMTC(msg, 'user');
cH.push({role: "user", content: msg});
cI.value = '';
tI(!1, isUT);

const apiCall = fetch(W_URL, {
method: 'POST', headers: {'Content-Type': 'application/json'},
body: JSON.stringify({history: cH, usePremiumModel: useP, ultraThink: isUT}),
});
const sim = isUT ? rUTS() : Promise.resolve();

try {
const [res] = await Promise.all([apiCall, sim]);
if (!res.ok) {
let eD = "No details.";
try {
const eData = await res.json();
if (eData.error) eD = eData.error;
} catch (e) { eD = res.statusText; }
throw new Error(`Server Error (${res.status}): ${eD}`);
}
const data = await res.json();
if (data.success && data.response) {
const lbl = data.isUltraThink ? "UltraThink Synthesis (4-Phase Iteration)" : null;
aMTC(data.response, 'bot', lbl);
cH.push({role: "assistant", content: data.response});
if (cH.length > 15) cH = cH.slice(-15);
} else {
if (data.isUltraThink && data.responses) {
data.responses.forEach((r, i) => {
aMTC(r, 'bot', `Legacy Instance ${i+1}`);
cH.push({role: "assistant", content: r});
});
} else throw new Error(data.error || "Unknown error.");
}} catch (error) {
let eM = `Error: ${error.message}`;
if (error instanceof TypeError) eM = "Network/CORS Error. Check backend.";
aMTC(eM, 'bot');
if (cH.length > 0 && cH[cH.length-1].role === 'user') cH.pop();
} finally { tI(!0); }
}

function aMTC(msg, sender, iL = null) {
const cM = document.getElementById('cm'), cW = document.getElementById('cw');
if (!cM || !cW) return;
const mE = document.createElement('div'); mE.classList.add('msg');
if (sender === 'user') {
mE.classList.add('um'); mE.textContent = msg;
} else {
mE.classList.add('bm');
if (iL) {
const lS = document.createElement('span'); lS.classList.add('il');
lS.textContent = iL + ":"; mE.appendChild(lS);
}
const cS = document.createElement('span'); cS.textContent = msg; mE.appendChild(cS);
}
cM.appendChild(mE);
cW.scrollTo({top: cW.scrollHeight, behavior: 'smooth'});
}

function tI(en, isUT = !1) {
const cI = document.getElementById('ci'), sB = document.getElementById('sb');
const tA = document.getElementById('jot'), uTB = document.getElementById('utb');
if (!cI || !sB) return;
cI.disabled = !en; sB.disabled = !en;
if (uTB) uTB.disabled = !en;
if (tA) { tA.style.pointerEvents = en ? 'auto' : 'none'; tA.style.opacity = en ? '1' : '0.5'; }
if (en) {
if (document.getElementById('pwdm').style.display !== 'flex') {
if (document.getElementById('ajo').style.display === 'flex') cI.focus();
}
cI.placeholder = "Type your question...";
} else {
if (isUT) cI.placeholder = "UltraThinking (Multi-Phase Iteration)...";
else cI.placeholder = "Thinking...";
}}

document.fonts.ready.then(() => { I(); }).catch(() => { I(); });
</script>
</body>
</html>
